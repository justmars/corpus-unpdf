{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"corpus-unpdf Docs","text":"<p>PDF, as a file format, is the bane of programmatic text analysis.</p> <p>It's not a document format like <code>.txt</code>, <code>.docx</code>, <code>.md</code>, etc. where elements of a document such as (a) layout, (b) words, (c) lines, etc. can be extracted easily.</p> <p>Instead, PDFs can be equated to instructions producing human-comprehensible, yet machine-confusing outputs.</p> <p>Humans can eyeball these outputs and understand the result. Machines however can only parse and make a guess as to its contents. Put another way:</p> <p>Note</p> <p>PDF = humans good, machines bad</p> <p>In light of this context, this library is an attempt to parse Philippine Supreme Court decisions issued in PDF format and extract its raw \"as guessed\" output.</p>"},{"location":"#measurements","title":"Measurements","text":"<p>Since we'll be using two distinct libraries with different formats, pay attention to the kind of measurements involved.</p>"},{"location":"#unit","title":"Unit","text":"Library Unit Description Maximum pdfplumber point PDF unit <code>im.shape</code> gets a tuple of the image dimensions opencv pixel Graphical unit <code>page.height * page.width</code> is the size of the page <p>Warning</p> <p>Note the two kinds of measurements involved. In order to use the image's pixels as page points, use the the image's max width / height as the divisor to get the ratio and then apply that ratio (percentage) to the page's max width / height.</p> Python<pre><code>&gt;&gt;&gt; from corpus_unpdf.src.common import get_contours # shortcut custom function\n&gt;&gt;&gt; im_h, im_w, im_d = im.shape # im_h is maximum image height\n&gt;&gt;&gt; test = next(cv2.boundingRect(c) for c in get_contours(im, (50, 10)))\n&gt;&gt;&gt; x, y, w, h = test # see Slicing below\n&gt;&gt;&gt; ratio = y / im_h # `y` coordinate over `im_h` gives a pixel-based ratio\n&gt;&gt;&gt; page_point = ratio * page.height # equivalent point in PDF page\n</code></pre> <p>See related discussion.</p>"},{"location":"#boxes","title":"Boxes","text":"<p>Slicing</p> Function Expectation Format Unit Description cv2.boundingRect() Results in a tuple of four points (<code>x</code>,<code>y</code>,<code>w</code>,<code>h</code>) pixels <code>x</code> is point in <code>x</code>-axis, <code>y</code> is point in y-axis, <code>w</code> is width, and <code>h</code> is height pdfplumber._typing.T_bbox A tuple of four points (<code>x0</code>, <code>y0</code>, <code>x1</code>, <code>y1</code>) points <code>x0</code> is the left-most point in x-axis, <code>x1</code> is the right-most point in x-axis, <code>y0</code> is the top-most point in y-axis, <code>y1</code> is the bottom-most point in y-axis."},{"location":"#setup","title":"Setup","text":""},{"location":"#common-libraries","title":"Common libraries","text":"<p>Install common libraries in MacOS with <code>homebrew</code>:</p> Bash<pre><code>brew install tesseract\nbrew install imagemagick\nbrew info imagemagick # check version\n</code></pre> <p>The last command gets you the local folder installed which will be needed in creating the virtual environment:</p> Text Only<pre><code>==&gt; imagemagick: stable 7.1.0-59 (bottled), HEAD\nTools and libraries to manipulate images in many formats\nhttps://imagemagick.org/index.php\n/opt/homebrew/Cellar/imagemagick/7.1.0-60 (807 files, 31MB) * &lt;---- first part is the local folder\nx x x\n</code></pre> <p>Note that both <code>tesseract</code> and <code>imagemagick</code> libraries are also made preconditions in <code>.github/workflows/main.yaml</code>:</p> YAML<pre><code>steps:\n# see https://github.com/madmaze/pytesseract/blob/master/.github/workflows/ci.yaml\n- name: Install tesseract\nrun: sudo apt-get -y update &amp;&amp; sudo apt-get install -y tesseract-ocr tesseract-ocr-fra\n- name: Print tesseract version\nrun: echo $(tesseract --version)\n# see https://github.com/jsvine/pdfplumber/blob/stable/.github/workflows/tests.yml\n- name: Install ghostscript &amp; imagemagick\nrun: sudo apt update &amp;&amp; sudo apt install ghostscript libmagickwand-dev\n- name: Remove policy.xml\nrun: sudo rm /etc/ImageMagick-6/policy.xml # this needs to be removed or the test won't run\n</code></pre>"},{"location":"#virtual-environment","title":"Virtual environment","text":"<p>Update <code>.env</code> whenever <code>imagemagick</code> changes</p> <p>The shared dependency is based on <code>MAGICK_HOME</code> folder. This can't seem to be fetched by python (at least in 3.11) so we need to help it along by explicitly declaring its location. The folder can change when a new version is installed via <code>brew upgrade imagemagick</code></p> <p>Create an .env file and use the folder as the environment variable <code>MAGICK_HOME</code>:</p> Text Only<pre><code>MAGICK_HOME=/opt/homebrew/Cellar/imagemagick/7.1.0-60\n</code></pre> <p>This configuration will allow <code>pdfplumber</code> to detect <code>imagemagick</code>.</p> <p>Effect of not setting <code>MAGICK_HOME</code>:</p> Python<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; pdfplumber.open&lt;(testpath&gt;).pages[0].to_image(resolution=300) # ERROR\n</code></pre> Text Only<pre><code>OSError: cannot find library; tried paths: []\n\nDuring handling of the above exception, another exception occurred:\n\nImportError                               Traceback (most recent call last)\n...\nImportError: MagickWand shared library not found.\nYou probably had not installed ImageMagick library.\nTry to install:\n  brew install freetype imagemagick\n</code></pre> <p>With <code>MAGICK_HOME</code>:</p> Python<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; pdfplumber.open&lt;(testpath&gt;).pages[0].to_image\nPIL.Image.Image # image library and type detected\n</code></pre> <p>Proceed to create the environment using <code>poetry update</code> which will install the following into a separate virtual environment:</p> TOML<pre><code>[tool.poetry.dependencies]\npython = \"^3.11\"\npython-dotenv = \"^0.21\"\npdfplumber = \"^0.7.6\" # from pdf to txt\npillow = \"^9.4.0\" # from pdf to img\nopencv-python = \"^4.7.0.68\" # img manipulation\npytesseract = \"^0.3.10\" # map manipulated img\n</code></pre>"},{"location":"decision/","title":"Pages","text":""},{"location":"decision/#get_decision","title":"get_decision","text":"<p>From a pdf file, get metadata filled Decision with pages cropped into bodies and annexes until the terminal page.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; decision = get_decision(x)\n&gt;&gt;&gt; decision.category\n&lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n&gt;&gt;&gt; decision.composition\n&lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n&gt;&gt;&gt; decision.writer\n'CARPIO, J.:'\n&gt;&gt;&gt; isinstance(decision.pages[0].lines[0], Bodyline)\nTrue\n&gt;&gt;&gt; decision.pages[0].footnotes == [] # none found, # TODO: can't seem to detect\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Decision</code> <p>Instance of a Decision with pages populated</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def get_decision(path: Path) -&gt; Decision:\n\"\"\"From a pdf file, get metadata filled Decision with pages\n    cropped into bodies and annexes until the terminal page.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; decision = get_decision(x)\n        &gt;&gt;&gt; decision.category\n        &lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n        &gt;&gt;&gt; decision.composition\n        &lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n        &gt;&gt;&gt; decision.writer\n        'CARPIO, J.:'\n        &gt;&gt;&gt; isinstance(decision.pages[0].lines[0], Bodyline)\n        True\n        &gt;&gt;&gt; decision.pages[0].footnotes == [] # none found, # TODO: can't seem to detect\n        True\n    Args:\n        path (Path): Path to the pdf file.\n    Returns:\n        Self: Instance of a Decision with pages populated\n    \"\"\"  # noqa: E501\npage, im = get_page_and_img(path, 0)\nif not (comp := PositionCourtComposition.extract(im)):\nraise _err(page, \"No court composition detected\")\nif not (caso := Decision.make_start_page(page, im, comp)):\nraise _err(page, \"First page unprocessed\")\nif not (page_pos := get_terminal_page_pos(path)):\nraise _err(page, \"No terminal detected\")\ndecision = caso.make_next_pages(path, page_pos[0], page_pos[1])\nreturn decision\n</code></pre>"},{"location":"decision/#decision-meta","title":"Decision Meta","text":"<p>Metadata of a pdf file parsed via <code>get_decision()</code></p> Field Description header The top portion of the page, usually excluded from metadata composition The composition of the Supreme Court that decided the case category When available, whether the case is a \"Decision\" or a \"Resolution\" writer When available, the writer of the case notice When True, means that there is no <code>category</code> available pages A list of Decision Pages with bodies/annexes Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@dataclass\nclass Decision:\n\"\"\"Metadata of a pdf file parsed via `get_decision()`\n    Field | Description\n    --:|:--\n    header | The top portion of the page, usually excluded from metadata\n    composition | The composition of the Supreme Court that decided the case\n    category | When available, whether the case is a \"Decision\" or a \"Resolution\"\n    writer | When available, the writer of the case\n    notice | When True, means that there is no `category` available\n    pages | A list of [Decision Pages with bodies/annexes][decision-page]\n    \"\"\"\nheader: CroppedPage\ncomposition: CourtCompositionChoices\ncategory: DecisionCategoryChoices | None = None\nwriter: str | None = None\nnotice: bool = False\npages: list[DecisionPage] = field(default_factory=list)\n@classmethod\ndef make_start_page(\ncls,\npage: Page,\nim: numpy.ndarray,\nstart: PositionCourtComposition,\n) -&gt; Self | None:\n\"\"\"The first page can either be a:\n        1. regular `Decision` page which contains a `writer`, `category`, and `header`;\n        2. a `Notice` page which will be marked by a `notice`.\n        Args:\n            page (Page): The pdfplumber variant of the first page\n            im (numpy.ndarray): Image of the `page` that will help us get a page's\n                end points `e1` and `e2`\n            start (PositionCourtComposition): The previously found y-axis\n                based component for slicing the `page`'s `im`\n        Returns:\n            Self | None: A Decision instance with the first page included.\n        \"\"\"\nlogger.debug(\"Initialize title page 1\")\nhead = start.composition_pct_height * page.height\nbody_end_line, terminal_line = get_page_end(im, page)\nlogger.debug(f\"Found {body_end_line=}; {terminal_line=}\")\nif ntc := PositionNotice.extract(im):\nnotice_pos = ntc.position_pct_height * page.height\nif notice_pos &gt;= body_end_line:\nraise _err(page, f\"{notice_pos=} must be &lt; {body_end_line=}\")\nlogger.debug(f\"Found {ntc=}; {notice_pos=}\")\nreturn cls(\nnotice=True,\ncomposition=start.element,\nheader=PageCut.set(page=page, y0=head, y1=notice_pos),\npages=[\nDecisionPage(\npage_num=1,\nbody=PageCut.set(\npage=page,\ny0=notice_pos,\ny1=body_end_line,\n),\nannex=(\nPageCut.set(\npage=page,\ny0=body_end_line,\ny1=terminal_line,\n)\nif terminal_line\nelse None\n),\n)\n],\n)\nelif category := PositionDecisionCategoryWriter.extract(im):\ncat_pos = category.category_pct_height * page.height\nwriter_pos = category.writer_pct_height * page.height\nif writer_pos &gt;= body_end_line:\nraise _err(page, f\"{writer_pos=} must be &lt; {body_end_line=}\")\nlogger.debug(f\"Found {cat_pos=}; {writer_pos=}\")\nreturn cls(\ncomposition=start.element,\ncategory=category.element,\nwriter=category.writer,\nheader=PageCut.set(page=page, y0=head, y1=cat_pos),\npages=[\nDecisionPage(\npage_num=1,\nbody=PageCut.set(\npage=page,\ny0=writer_pos,\ny1=body_end_line,\n),\nannex=(\nPageCut.set(\npage=page,\ny0=body_end_line,\ny1=terminal_line,\n)\nif terminal_line\nelse None\n),\n)\n],\n)\nlogger.error(\"Could not detect category or notice.\")\nreturn None\ndef make_next_pages(self, path: Path, last_num: int, last_y: int) -&gt; Self:\n\"\"\"After the first page is created, add subsequent pages taking into\n        account the terminal page and line. When the terminal page `last_num`\n        is reached, stop the for-loop.\n        Args:\n            path (Path): Path to the pdf file.\n            last_num (int): The terminal page\n            last_y (int): The y-axis point of the terminal page\n        Returns:\n            Self: The Decision instance containing any added pages from\n                the for loop.\n        \"\"\"\nfor page in pdfplumber.open(path).pages:\nif (num := page.page_number) == 1:\ncontinue\nif num == last_num:\nlogger.debug(f\"Finalize {page.page_number=}.\")\nif page_valid := DecisionPage.extract(path, num, last_y):\nself.pages.append(page_valid)\npage.pdf.close()\nelse:\nlogger.warning(\"Detected blank page.\")\nbreak\nelse:\nlogger.debug(f\"Initialize {page.page_number=}.\")\nif page_valid := DecisionPage.extract(path, num):\nself.pages.append(page_valid)\nelse:\nlogger.warning(\"Detected blank page.\")\nreturn self\n</code></pre>"},{"location":"decision/#corpus_unpdf.Decision-functions","title":"Functions","text":""},{"location":"decision/#corpus_unpdf.decision.Decision.make_next_pages","title":"<code>make_next_pages(path, last_num, last_y)</code>","text":"<p>After the first page is created, add subsequent pages taking into account the terminal page and line. When the terminal page <code>last_num</code> is reached, stop the for-loop.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <code>last_num</code> <code>int</code> <p>The terminal page</p> required <code>last_y</code> <code>int</code> <p>The y-axis point of the terminal page</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The Decision instance containing any added pages from the for loop.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def make_next_pages(self, path: Path, last_num: int, last_y: int) -&gt; Self:\n\"\"\"After the first page is created, add subsequent pages taking into\n    account the terminal page and line. When the terminal page `last_num`\n    is reached, stop the for-loop.\n    Args:\n        path (Path): Path to the pdf file.\n        last_num (int): The terminal page\n        last_y (int): The y-axis point of the terminal page\n    Returns:\n        Self: The Decision instance containing any added pages from\n            the for loop.\n    \"\"\"\nfor page in pdfplumber.open(path).pages:\nif (num := page.page_number) == 1:\ncontinue\nif num == last_num:\nlogger.debug(f\"Finalize {page.page_number=}.\")\nif page_valid := DecisionPage.extract(path, num, last_y):\nself.pages.append(page_valid)\npage.pdf.close()\nelse:\nlogger.warning(\"Detected blank page.\")\nbreak\nelse:\nlogger.debug(f\"Initialize {page.page_number=}.\")\nif page_valid := DecisionPage.extract(path, num):\nself.pages.append(page_valid)\nelse:\nlogger.warning(\"Detected blank page.\")\nreturn self\n</code></pre>"},{"location":"decision/#corpus_unpdf.decision.Decision.make_start_page","title":"<code>make_start_page(page, im, start)</code>  <code>classmethod</code>","text":"<p>The first page can either be a:</p> <ol> <li>regular <code>Decision</code> page which contains a <code>writer</code>, <code>category</code>, and <code>header</code>;</li> <li>a <code>Notice</code> page which will be marked by a <code>notice</code>.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>The pdfplumber variant of the first page</p> required <code>im</code> <code>numpy.ndarray</code> <p>Image of the <code>page</code> that will help us get a page's end points <code>e1</code> and <code>e2</code></p> required <code>start</code> <code>PositionCourtComposition</code> <p>The previously found y-axis based component for slicing the <code>page</code>'s <code>im</code></p> required <p>Returns:</p> Type Description <code>Self | None</code> <p>Self | None: A Decision instance with the first page included.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@classmethod\ndef make_start_page(\ncls,\npage: Page,\nim: numpy.ndarray,\nstart: PositionCourtComposition,\n) -&gt; Self | None:\n\"\"\"The first page can either be a:\n    1. regular `Decision` page which contains a `writer`, `category`, and `header`;\n    2. a `Notice` page which will be marked by a `notice`.\n    Args:\n        page (Page): The pdfplumber variant of the first page\n        im (numpy.ndarray): Image of the `page` that will help us get a page's\n            end points `e1` and `e2`\n        start (PositionCourtComposition): The previously found y-axis\n            based component for slicing the `page`'s `im`\n    Returns:\n        Self | None: A Decision instance with the first page included.\n    \"\"\"\nlogger.debug(\"Initialize title page 1\")\nhead = start.composition_pct_height * page.height\nbody_end_line, terminal_line = get_page_end(im, page)\nlogger.debug(f\"Found {body_end_line=}; {terminal_line=}\")\nif ntc := PositionNotice.extract(im):\nnotice_pos = ntc.position_pct_height * page.height\nif notice_pos &gt;= body_end_line:\nraise _err(page, f\"{notice_pos=} must be &lt; {body_end_line=}\")\nlogger.debug(f\"Found {ntc=}; {notice_pos=}\")\nreturn cls(\nnotice=True,\ncomposition=start.element,\nheader=PageCut.set(page=page, y0=head, y1=notice_pos),\npages=[\nDecisionPage(\npage_num=1,\nbody=PageCut.set(\npage=page,\ny0=notice_pos,\ny1=body_end_line,\n),\nannex=(\nPageCut.set(\npage=page,\ny0=body_end_line,\ny1=terminal_line,\n)\nif terminal_line\nelse None\n),\n)\n],\n)\nelif category := PositionDecisionCategoryWriter.extract(im):\ncat_pos = category.category_pct_height * page.height\nwriter_pos = category.writer_pct_height * page.height\nif writer_pos &gt;= body_end_line:\nraise _err(page, f\"{writer_pos=} must be &lt; {body_end_line=}\")\nlogger.debug(f\"Found {cat_pos=}; {writer_pos=}\")\nreturn cls(\ncomposition=start.element,\ncategory=category.element,\nwriter=category.writer,\nheader=PageCut.set(page=page, y0=head, y1=cat_pos),\npages=[\nDecisionPage(\npage_num=1,\nbody=PageCut.set(\npage=page,\ny0=writer_pos,\ny1=body_end_line,\n),\nannex=(\nPageCut.set(\npage=page,\ny0=body_end_line,\ny1=terminal_line,\n)\nif terminal_line\nelse None\n),\n)\n],\n)\nlogger.error(\"Could not detect category or notice.\")\nreturn None\n</code></pre>"},{"location":"decision/#decision-page","title":"Decision Page","text":"<p>Metadata of a single page of the pdf file parsed via <code>get_decision()</code></p> Field Description <code>page_num</code> The page number of the Decision page <code>body</code> The main content above the annex, if existing <code>lines</code> Segments of the <code>body</code>'s text in the given <code>page_num</code> <code>annex</code> Portion of page containing the footnotes; some pages are annex-free <code>footnotes</code> Each footnote item in the <code>annex</code>'s text in the given <code>page_num</code> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@dataclass\nclass DecisionPage:\n\"\"\"Metadata of a single page of the pdf file parsed via `get_decision()`\n    Field | Description\n    --:|:--\n    `page_num` | The page number of the Decision page\n    `body` | The main content above the annex, if existing\n    `lines` | Segments of the `body`'s text in the given `page_num`\n    `annex` | Portion of page containing the footnotes; some pages are annex-free\n    `footnotes` | Each footnote item in the `annex`'s text in the given `page_num`\n    \"\"\"\npage_num: int\nbody: CroppedPage\nannex: CroppedPage | None = None\nlines: list[Bodyline] = field(default_factory=list)\nfootnotes: list[Footnote] = field(default_factory=list)\ndef __post_init__(self):\nself.lines = Bodyline.from_cropped(self.body)\nif self.annex:\nself.footnotes = Footnote.from_cropped(self.annex)\n@classmethod\ndef extract(\ncls,\npath: Path,\npage_num: int = 2,\nterminal_y: int | None = None,\n) -&gt; Self | None:\n\"\"\"Each `page_num` should have a `body`, and optionally an `annex`\n        Args:\n            path (Path): Path to the pdf file.\n            page_num (int, optional): Will deduct 1 for slicing. Defaults to 2.\n            terminal_y (int | None, optional): If present, refers to\n                The y-axis point of the terminal page. Defaults to None.\n        Returns:\n            Self: Page with individual components mapped out.\n        \"\"\"\nif page_num &lt;= 1:\nraise Exception(\"Must not be the first page.\")\npage, im = get_page_and_img(path, page_num - 1)\n# preflight check to determine if blank\nif len(page.extract_text()) &lt; 100:\nreturn None\n# the header line determines the start of the body proper\nheader_line = get_header_line(im, page)\nif not header_line:\nraise _err(page, \"No header line\")\n# necessary because of blank pages\nextracted_page_num = get_page_num(page, header_line) or 0\n# get body_end_line and terminal_line for annex and body vertical borders\nbody_end_line, terminal_line = get_page_end(im, page)\nannex = None\nif terminal_line:\nannex = PageCut.set(page=page, y0=body_end_line, y1=terminal_line)\nif terminal_y:\nbody_end_line = terminal_y\nbody = PageCut.set(page=page, y0=header_line, y1=body_end_line)\nreturn cls(body=body, annex=annex, page_num=extracted_page_num)\n</code></pre>"},{"location":"decision/#corpus_unpdf.DecisionPage-functions","title":"Functions","text":""},{"location":"decision/#corpus_unpdf.decision.DecisionPage.extract","title":"<code>extract(path, page_num=2, terminal_y=None)</code>  <code>classmethod</code>","text":"<p>Each <code>page_num</code> should have a <code>body</code>, and optionally an <code>annex</code></p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <code>page_num</code> <code>int</code> <p>Will deduct 1 for slicing. Defaults to 2.</p> <code>2</code> <code>terminal_y</code> <code>int | None</code> <p>If present, refers to The y-axis point of the terminal page. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self | None</code> <p>Page with individual components mapped out.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@classmethod\ndef extract(\ncls,\npath: Path,\npage_num: int = 2,\nterminal_y: int | None = None,\n) -&gt; Self | None:\n\"\"\"Each `page_num` should have a `body`, and optionally an `annex`\n    Args:\n        path (Path): Path to the pdf file.\n        page_num (int, optional): Will deduct 1 for slicing. Defaults to 2.\n        terminal_y (int | None, optional): If present, refers to\n            The y-axis point of the terminal page. Defaults to None.\n    Returns:\n        Self: Page with individual components mapped out.\n    \"\"\"\nif page_num &lt;= 1:\nraise Exception(\"Must not be the first page.\")\npage, im = get_page_and_img(path, page_num - 1)\n# preflight check to determine if blank\nif len(page.extract_text()) &lt; 100:\nreturn None\n# the header line determines the start of the body proper\nheader_line = get_header_line(im, page)\nif not header_line:\nraise _err(page, \"No header line\")\n# necessary because of blank pages\nextracted_page_num = get_page_num(page, header_line) or 0\n# get body_end_line and terminal_line for annex and body vertical borders\nbody_end_line, terminal_line = get_page_end(im, page)\nannex = None\nif terminal_line:\nannex = PageCut.set(page=page, y0=body_end_line, y1=terminal_line)\nif terminal_y:\nbody_end_line = terminal_y\nbody = PageCut.set(page=page, y0=header_line, y1=body_end_line)\nreturn cls(body=body, annex=annex, page_num=extracted_page_num)\n</code></pre>"},{"location":"footer/","title":"Footer","text":""},{"location":"footer/#annex-existence-as-page-y-axis-ends","title":"Annex Existence as Page Y-Axis End/s","text":"<p>Given an <code>im</code>, detect the footnote line of the annex and return relevant points in the y-axis as a tuple.</p> Scenario Description y0 y1 Footnote line exists Page contains footnotes int or float int or float signifying end of page Footnote line absent Page does not contain footnotes int or float signifying end of page <code>None</code> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>the openCV image that may contain a footnote line</p> required <code>page</code> <code>Page</code> <p>the pdfplumber.page.Page based on <code>im</code></p> required <p>Returns:</p> Type Description <code>tuple[float, float | None]</code> <p>tuple[float, float | None]: The annex line's y-axis (if it exists) and The page's end content line</p> Source code in <code>corpus_unpdf/src/footer.py</code> Python<pre><code>def get_page_end(im: numpy.ndarray, page: Page) -&gt; tuple[float, float | None]:\n\"\"\"Given an `im`, detect the footnote line of the annex and return\n    relevant points in the y-axis as a tuple.\n    Scenario | Description | y0 | y1\n    :--:|:-- |:--:|:--:\n    Footnote line exists | Page contains footnotes | int or float | int or float signifying end of page\n    Footnote line absent | Page does not contain footnotes | int or float signifying end of page | `None`\n    Args:\n        im (numpy.ndarray): the openCV image that may contain a footnote line\n        page (Page): the pdfplumber.page.Page based on `im`\n    Returns:\n        tuple[float, float | None]: The annex line's y-axis (if it exists) and\n            The page's end content line\n    \"\"\"  # noqa: E501\nim_h, _, _ = im.shape\nfn = get_footer_line_coordinates(im)\ny1 = PERCENT_OF_MAX_PAGE * page.height\nif fn:\n_, y, _, _ = fn\nfn_line_end = y / im_h\ny0 = fn_line_end * page.height\nreturn y0, y1\nreturn y1, None\n</code></pre>"},{"location":"footer/#footer-line-coordinates","title":"Footer Line Coordinates","text":"<p>The footer represents content below the main content. This is also called the annex of the page.</p> <p>This detects a short line in the lower half of the page that has at least a width of 400 pixels and a height of less than 40 pixels, indicating a narrow box (as dilated by openCV). Text found below this box represents the annex.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 0 marks the second page\n&gt;&gt;&gt; get_footer_line_coordinates(im)\n(426, 3148, 499, 13)\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The full page image</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int, int] | None</code> <p>tuple[int, int, int, int] | None: The coordinates of the footer line, if found.</p> Source code in <code>corpus_unpdf/src/footer.py</code> Python<pre><code>def get_footer_line_coordinates(\nim: numpy.ndarray,\n) -&gt; tuple[int, int, int, int] | None:\n\"\"\"The footer represents content below the main content. This is also\n    called the annex of the page.\n    This detects a short line in the lower half of the page that has at least a width\n    of 400 pixels and a height of less than 40 pixels, indicating a narrow box\n    (as dilated by openCV). Text found below this box represents the annex.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 0 marks the second page\n        &gt;&gt;&gt; get_footer_line_coordinates(im)\n        (426, 3148, 499, 13)\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        im (numpy.ndarray): The full page image\n    Returns:\n        tuple[int, int, int, int] | None: The coordinates of the footer line, if found.\n    \"\"\"\nim_h, im_w, _ = im.shape\nfor c in get_contours(im, (50, 10)):\nx, y, w, h = cv2.boundingRect(c)\nx0_on_left_side = x &lt; (im_w / 2)\nx1_on_left_side = (x + w) &lt; (im_w / 2)\nshort_line = (im_w / 2) &gt; w &gt; 400\nshort_height = h &lt; 50\nif all([short_line, x0_on_left_side, x1_on_left_side, short_height]):\n# cv2.rectangle(im, (x, y), (x + w, y + h), (36, 255, 12), 3)\n# cv2.imwrite(\"temp/sample_boxes.png\", im)\nreturn x, y, w, h\nreturn None\n</code></pre>"},{"location":"header/","title":"Header","text":""},{"location":"header/#page-y-axis-start","title":"Page Y-Axis Start","text":"<p>The header represents non-title page content above the main content.</p> <p>The terminating header line is a non-visible line that separates the decision's header from its main content. We'll use a typographic bottom of the header to signify this line.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 1 marks the second page\n&gt;&gt;&gt; get_header_line(im, page)\n75.12\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The full page image</p> required <code>page</code> <code>Page</code> <p>The pdfplumber page</p> required <p>Returns:</p> Type Description <code>int | float | None</code> <p>float | None: Y-axis point (pdfplumber point) at bottom of header</p> Source code in <code>corpus_unpdf/src/header.py</code> Python<pre><code>def get_header_line(im: numpy.ndarray, page: Page) -&gt; int | float | None:\n\"\"\"The header represents non-title page content above the main content.\n    The terminating header line is a non-visible line that separates the\n    decision's header from its main content. We'll use a typographic bottom\n    of the [header][docket-coordinates] to signify this line.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 1 marks the second page\n        &gt;&gt;&gt; get_header_line(im, page)\n        75.12\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        im (numpy.ndarray): The full page image\n        page (Page): The pdfplumber page\n    Returns:\n        float | None: Y-axis point (pdfplumber point) at bottom of header\n    \"\"\"\nim_h, _, _ = im.shape\nif hd := get_header_docket_coordinates(im):\n_, y, _, h = hd\nheader_end = (y + h) / im_h\nterminal = header_end * page.height\nreturn terminal\nreturn None\n</code></pre>"},{"location":"header/#docket-coordinates","title":"Docket Coordinates","text":"<p>The header represents non-title page content above the main content.</p> <p>It usually consists of three items:</p> Item Label Example 1 Type of decision <code>Resolution</code> or <code>Decision</code> 2 Page number 1, 2, 3, etc. 3 Docket of the decision involved GR. 12414, Dec. 1, 2023 <p>This detects Item (3) which implies that it is the in upper right quarter of the document:</p> Python<pre><code>x &gt; im_w / 2 # ensures that it is on the right side of the page\ny &lt;= im_h * 0.2 # ensures that it is on the top quarter of the page\n</code></pre> <p>Item (3) is the only one above that is likely to have a second vertical line, hence choosing this as the the typographic bottom for the header makes sense.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 0 marks the second page\n&gt;&gt;&gt; get_header_docket_coordinates(im)\n(1813, 229, 460, 84)\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The full page image</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int, int] | None</code> <p>tuple[int, int, int, int] | None: The coordinates of the docket, if found.</p> Source code in <code>corpus_unpdf/src/header.py</code> Python<pre><code>def get_header_docket_coordinates(\nim: numpy.ndarray,\n) -&gt; tuple[int, int, int, int] | None:\n\"\"\"The header represents non-title page content above the main content.\n    It usually consists of three items:\n    Item | Label | Example\n    --:|:--|:--\n    1 | Type of decision | `Resolution` or `Decision`\n    2 | Page number | 1, 2, 3, etc.\n    3 | Docket of the decision involved | GR. 12414, Dec. 1, 2023\n    This detects Item (3) which implies that it is the in upper right quarter\n    of the document:\n    ```py\n    x &gt; im_w / 2 # ensures that it is on the right side of the page\n    y &lt;= im_h * 0.2 # ensures that it is on the top quarter of the page\n    ```\n    Item (3) is the only one above that is likely to have a second vertical line,\n    hence choosing this as the the typographic bottom for the header makes sense.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 0 marks the second page\n        &gt;&gt;&gt; get_header_docket_coordinates(im)\n        (1813, 229, 460, 84)\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        im (numpy.ndarray): The full page image\n    Returns:\n        tuple[int, int, int, int] | None: The coordinates of the docket, if found.\n    \"\"\"\nim_h, im_w, _ = im.shape\nfor cnt in get_contours(im, (50, 50)):\nx, y, w, h = cv2.boundingRect(cnt)\nif x &gt; im_w / 2 and y &lt;= im_h * 0.25 and w &gt; 200:\nreturn x, y, w, h\nreturn None\n</code></pre>"},{"location":"header/#page-number","title":"Page Number","text":"<p>Get the first matching digit in the header's text. This helps deal with decisions having blank pages.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 1 marks the second page\n&gt;&gt;&gt; header_line = get_header_line(im, page)\n&gt;&gt;&gt; get_page_num(page, header_line)\n2\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>The pdfplumber page</p> required <code>header_line</code> <code>int | float</code> <p>The value retrieved from <code>get_header_line()</code></p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: The page number, if found</p> Source code in <code>corpus_unpdf/src/header.py</code> Python<pre><code>def get_page_num(page: Page, header_line: int | float) -&gt; int | None:\n\"\"\"Get the first matching digit in the header's text. This helps\n    deal with decisions having blank pages.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 1 marks the second page\n        &gt;&gt;&gt; header_line = get_header_line(im, page)\n        &gt;&gt;&gt; get_page_num(page, header_line)\n        2\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        page (Page): The pdfplumber page\n        header_line (int | float): The value retrieved from `get_header_line()`\n    Returns:\n        int | None: The page number, if found\n    \"\"\"\nbox = (0, 0, page.width, header_line)\nheader = page.crop(box, relative=False, strict=True)\ntexts = header.extract_text(layout=True, keep_blank_chars=True).split()\nfor text in texts:\nif text.isdigit() and len(text) &lt;= 3:\nreturn int(text)\nreturn None\n</code></pre>"},{"location":"markers/","title":"Markers","text":"<p>Typically used in the first page of a Decision document to determine the positions of Y-coordinates and to extract the metadata associated with the page.</p>"},{"location":"markers/#court-composition","title":"Court Composition","text":""},{"location":"markers/#composition-choices","title":"Composition Choices","text":"<p>         Bases: <code>Enum</code></p> <p>How the Supreme Court sits. At present, this includes four options. Might need to add cases for special divisions.</p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class CourtCompositionChoices(Enum):\n\"\"\"How the Supreme Court sits. At present, this includes four\n    options. Might need to add cases for _special_ divisions.\"\"\"\nENBANC = \"En Banc\"\nDIV1 = \"First Division\"\nDIV2 = \"Second Division\"\nDIV3 = \"Third Division\"\n</code></pre>"},{"location":"markers/#extract-composition","title":"Extract Composition","text":"<p>         Bases: <code>NamedTuple</code></p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class PositionCourtComposition(NamedTuple):\nelement: CourtCompositionChoices\ncoordinates: tuple[int, int, int, int]\ncomposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in CourtCompositionChoices:\nif xywh := get_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\ncomposition_pct_height=(y + h) / im_h,\n)\nreturn None\n</code></pre>"},{"location":"markers/#decision-category-writer","title":"Decision Category &amp; Writer","text":""},{"location":"markers/#category-choices","title":"Category Choices","text":"<p>         Bases: <code>Enum</code></p> <p>The classification of a decision issued by the Supreme Court.</p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class DecisionCategoryChoices(Enum):\n\"\"\"The classification of a decision issued by the Supreme Court.\"\"\"\nCASO = \"Decision\"\nRESO = \"Resolution\"\n</code></pre>"},{"location":"markers/#extract-category","title":"Extract Category","text":"<p>         Bases: <code>NamedTuple</code></p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class PositionDecisionCategoryWriter(NamedTuple):\nelement: DecisionCategoryChoices\ncoordinates: tuple[int, int, int, int]\nwriter: str\ncategory_pct_height: float\nwriter_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in DecisionCategoryChoices:\nif xywh := get_centered_coordinates(im, member.value):\n_, y, _, h = xywh\ny0, y1 = y + h, y + 270\nwriter_box = im[y0:y1]\nreturn cls(\nelement=member,\ncoordinates=xywh,\nwriter=pytesseract.image_to_string(writer_box).strip(),\ncategory_pct_height=y / im_h,\nwriter_pct_height=y1 / im_h,\n)\nreturn None\n</code></pre>"},{"location":"markers/#notice","title":"Notice","text":"<p>         Bases: <code>NamedTuple</code></p> <p>When present, signifies that this was issued by authority of the Court.</p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class PositionNotice(NamedTuple):\n\"\"\"When present, signifies that this was issued by authority of the Court.\"\"\"\nelement: NoticeChoices\ncoordinates: tuple[int, int, int, int]\nposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in NoticeChoices:\nif xywh := get_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\nposition_pct_height=(y + h) / im_h,\n)\nreturn None\n</code></pre>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#fetch-pdfs","title":"Fetch PDFs","text":"<p>Work with pdf files.</p>"},{"location":"utils/#extract-page-image","title":"Extract page, image","text":"<p>Combines <code>OpenCV</code> with <code>pdfplumber</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 0) # 0 marks the first page\n&gt;&gt;&gt; page.page_number # the first page\n1\n&gt;&gt;&gt; isinstance(page, Page)\nTrue\n&gt;&gt;&gt; isinstance(im, numpy.ndarray)\nTrue\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>str | Path</code> <p>Path to the PDF file.</p> required <code>index</code> <code>int</code> <p>Zero-based index that determines the page number.</p> required <p>Returns:</p> Type Description <code>tuple[Page, numpy.ndarray]</code> <p>tuple[Page, numpy.ndarray]: Page identified by <code>index</code>  with image of the page  (in numpy format) that can be manipulated.</p> Source code in <code>corpus_unpdf/src/common/fetch.py</code> Python<pre><code>def get_page_and_img(\npdfpath: str | Path, index: int\n) -&gt; tuple[Page, numpy.ndarray]:\n\"\"\"Combines `OpenCV` with `pdfplumber`.\n    Examples:\n        &gt;&gt;&gt; import numpy\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 0) # 0 marks the first page\n        &gt;&gt;&gt; page.page_number # the first page\n        1\n        &gt;&gt;&gt; isinstance(page, Page)\n        True\n        &gt;&gt;&gt; isinstance(im, numpy.ndarray)\n        True\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        pdfpath (str | Path): Path to the PDF file.\n        index (int): Zero-based index that determines the page number.\n    Returns:\n        tuple[Page, numpy.ndarray]: Page identified by `index`  with image of the\n            page  (in numpy format) that can be manipulated.\n    \"\"\"\npdf = pdfplumber.open(pdfpath)\npage = pdf.pages[index]\nimg = get_img_from_page(page)\nreturn page, img\n</code></pre>"},{"location":"utils/#reverse-list-pages-images","title":"Reverse list pages, images","text":"<p>Start from the end page to get to the first page to determine terminal values.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; results = get_reverse_pages_and_imgs(x)\n&gt;&gt;&gt; result = next(results)\n&gt;&gt;&gt; type(result)\n&lt;class 'tuple'&gt;\n&gt;&gt;&gt; isinstance(result[0], Page)\nTrue\n&gt;&gt;&gt; assert result[0].page_number == len(pdfplumber.open(x).pages) # last first\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>str | Path</code> <p>Path to the PDF file.</p> required <p>Yields:</p> Type Description <code>Iterator[tuple[Page, numpy.ndarray]]</code> <p>Iterator[tuple[Page, numpy.ndarray]]: Pages with respective images</p> Source code in <code>corpus_unpdf/src/common/fetch.py</code> Python<pre><code>def get_reverse_pages_and_imgs(\npdfpath: str | Path,\n) -&gt; Iterator[tuple[Page, numpy.ndarray]]:\n\"\"\"Start from the end page to get to the first page\n    to determine terminal values.\n    Examples:\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; results = get_reverse_pages_and_imgs(x)\n        &gt;&gt;&gt; result = next(results)\n        &gt;&gt;&gt; type(result)\n        &lt;class 'tuple'&gt;\n        &gt;&gt;&gt; isinstance(result[0], Page)\n        True\n        &gt;&gt;&gt; assert result[0].page_number == len(pdfplumber.open(x).pages) # last first\n    Args:\n        pdfpath (str | Path): Path to the PDF file.\n    Yields:\n        Iterator[tuple[Page, numpy.ndarray]]: Pages with respective images\n    \"\"\"\nwith pdfplumber.open(pdfpath) as pdf:\nindex = len(pdf.pages) - 1\nwhile True:\npage = pdf.pages[index]\nyield page, get_img_from_page(page)\nif index == 0:\nbreak\nindex -= 1\n</code></pre>"},{"location":"utils/#get-terminal-page-position","title":"Get terminal page, position","text":"<p>Although the collection of pages has a logical end page, this oftentimes does not correspond to the actual end of the content.</p> <p>The actual end of content depends on either two pieces of text: the <code>Ordered</code> clause or <code>By Authority of the Court</code></p> <p>This requires searching the page in reverse, via <code>get_reverse_pages_and_imgs()</code> since the above pieces of text indicate the end of the content.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n&gt;&gt;&gt; get_terminal_page_pos(x) # page 5, y-axis 80.88\n(5, 80.88)\n</code></pre> <p>Also see snippets for debugging:</p> Python<pre><code>debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\ncv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\ncv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the PDF file.</p> required <p>Returns:</p> Type Description <code>tuple[int, int] | None</code> <p>tuple[int, int] | None: The page number from pdfplumber.pages, the Y position of that page</p> Source code in <code>corpus_unpdf/src/common/fetch.py</code> Python<pre><code>def get_terminal_page_pos(path: Path) -&gt; tuple[int, int] | None:\n\"\"\"Although the collection of pages has a logical end page, this\n    oftentimes does not correspond to the actual end of the content.\n    The actual end of content depends on either two pieces of text:\n    the `Ordered` clause or `By Authority of the Court`\n    This requires searching the page in reverse, via\n    `get_reverse_pages_and_imgs()` since the above pieces of text\n    indicate the end of the content.\n    Examples:\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n        &gt;&gt;&gt; get_terminal_page_pos(x) # page 5, y-axis 80.88\n        (5, 80.88)\n    Also see snippets for debugging:\n    ```py\n    debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\n    cv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\n    cv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n    ```\n    Args:\n        path (Path): Path to the PDF file.\n    Returns:\n        tuple[int, int] | None: The page number from pdfplumber.pages, the Y position\n            of that page\n    \"\"\"\nORDERED, AUTHORITY = \"so ordered\", \"by authority of the court\"\nfor page, im in get_reverse_pages_and_imgs(path):\nim_h, im_w, _ = im.shape\nMIDPOINT = im_w / 2\nfor cnt in get_contours(im, (30, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\nsliced_im = im[y : y + h, x : x + w]\noutput = page.page_number, (y / im_h) * page.height\nif h &lt; 100:\nif x &lt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=ORDERED,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nelif x &gt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=AUTHORITY,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nreturn None\n</code></pre>"},{"location":"utils/#slice-images-pages","title":"Slice images &amp; pages","text":"<p>Using pre-processed PDF files above, slice images and/or pages based on certain criteria.</p>"},{"location":"utils/#get-contours-from-image","title":"Get contours from image","text":"<p>Generally follows the strategy outlined here:</p> <ol> <li>Youtube video</li> <li>Stack Overflow answer</li> </ol> <p>The structuring element used will be a rectangle of dimensions specified in <code>rectangle_size</code>. After dilating the image, the contours can be enumerated for further processing and matching, e.g. after the image is transformed, can find which lines appear in the center or in the top right quadrant, etc.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The opencv formatted image</p> required <code>rectangle_size</code> <code>tuple[int, int]</code> <p>The width and height to morph the characters</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The contours found based on the specified structuring element</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>def get_contours(im: numpy.ndarray, rectangle_size: tuple[int, int]) -&gt; list:\n\"\"\"Generally follows the strategy outlined here:\n    1. [Youtube video](https://www.youtube.com/watch?v=ZeCRe9sNFwk&amp;list=PL2VXyKi-KpYuTAZz__9KVl1jQz74bDG7i&amp;index=11)\n    2. [Stack Overflow answer](https://stackoverflow.com/a/57262099)\n    The structuring element used will be a rectangle of dimensions\n    specified in `rectangle_size`. After dilating the image,\n    the contours can be enumerated for further processing and\n    matching, e.g. after the image is transformed, can find\n    which lines appear in the center or in the top right quadrant, etc.\n    Args:\n        im (numpy.ndarray): The opencv formatted image\n        rectangle_size (tuple[int, int]): The width and height to morph the characters\n    Returns:\n        list: The contours found based on the specified structuring element\n    \"\"\"  # noqa: E501\ngray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray, (7, 7), 0)\nthresh = cv2.threshold(\nblur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU\n)[1]\nkernel = cv2.getStructuringElement(cv2.MORPH_RECT, rectangle_size)\ndilate = cv2.dilate(thresh, kernel, iterations=1)\ncv2.imwrite(\"temp/sample_dilated.png\", dilate)\ncnts = cv2.findContours(dilate, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\ncnts = cnts[0] if len(cnts) == 2 else cnts[1]\nreturn sorted(cnts, key=lambda x: cv2.boundingRect(x)[1])\n</code></pre>"},{"location":"utils/#test-image-matches-text","title":"Test image matches text","text":"<p>Test whether textual image in <code>sliced_im</code> resembles <code>text_to_match</code> by a <code>likelihood</code> percentage.</p> <p>Parameters:</p> Name Type Description Default <code>sliced_im</code> <code>numpy.ndarray</code> <p>Slice of a larger image containing text</p> required <code>text_to_match</code> <code>str</code> <p>How to match the text slice in <code>im</code></p> required <code>likelihood</code> <code>float</code> <p>Allowed percentage expressed in decimals</p> <code>0.7</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether or not the <code>text_to_match</code> resembles <code>sliced_im</code>'s text.</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>def is_match_text(\nsliced_im: numpy.ndarray,\ntext_to_match: str,\nlikelihood: float = 0.7,\n) -&gt; bool:\n\"\"\"Test whether textual image in `sliced_im` resembles `text_to_match` by\n    a `likelihood` percentage.\n    Args:\n        sliced_im (numpy.ndarray): Slice of a larger image containing text\n        text_to_match (str): How to match the text slice in `im`\n        likelihood (float): Allowed percentage expressed in decimals\n    Returns:\n        bool: Whether or not the `text_to_match` resembles `sliced_im`'s text.\n    \"\"\"\nupper_candidate = pytesseract.image_to_string(sliced_im).strip().upper()\nupper_matcher = text_to_match.upper()\nmatch = SequenceMatcher(None, a=upper_candidate, b=upper_matcher)\nreturn match.ratio() &gt; likelihood\n</code></pre>"},{"location":"utils/#centered-text-matching-contours","title":"Centered text matching contours","text":"<p>With a image <code>im</code>, get all contours found in the center of the image and then for each of these matches, if they are text resembling <code>text_to_match</code>, extract the coordinates of such contours.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 0)\n&gt;&gt;&gt; get_centered_coordinates(im, 'Decision') # None found\n&gt;&gt;&gt; get_centered_coordinates(im, 'Resolution')\n(1043, 2118, 614, 72)\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The base image to look for text</p> required <code>text_to_match</code> <code>str</code> <p>The words that should match</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int, int] | None</code> <p>tuple[int, int, int, int] | None: (x, y, w, h) pixels representing <code>cv2.boundingRect</code>, if found.</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>def get_centered_coordinates(\nim: numpy.ndarray, text_to_match: str\n) -&gt; tuple[int, int, int, int] | None:\n\"\"\"With a image `im`, get all contours found in the center\n    of the image and then for each of these matches, if they\n    are text resembling `text_to_match`, extract the coordinates of\n    such contours.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 0)\n        &gt;&gt;&gt; get_centered_coordinates(im, 'Decision') # None found\n        &gt;&gt;&gt; get_centered_coordinates(im, 'Resolution')\n        (1043, 2118, 614, 72)\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        im (numpy.ndarray): The base image to look for text\n        text_to_match (str): The words that should match\n    Returns:\n        tuple[int, int, int, int] | None: (x, y, w, h) pixels representing\n            `cv2.boundingRect`, if found.\n    \"\"\"\n_, im_w, _ = im.shape\nfor cnt in get_contours(im, (100, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\nx0_mid_left = (1 * im_w) / 4 &lt; x\nendpoint_on_right = x + w &gt; im_w / 2\nshort_width = w &gt; 200\nif all([x0_mid_left, endpoint_on_right, short_width]):\n# cv2.rectangle(im, (x, y), (x + w, y + h), (36, 255, 12), 3)\n# cv2.imwrite(\"temp/sample_boxes.png\", im)\nif is_match_text(\nsliced_im=im[y : y + h, x : x + w],\ntext_to_match=text_to_match,\nlikelihood=0.7,\n):\nreturn x, y, w, h\nreturn None\n</code></pre>"},{"location":"utils/#get-slice-of-page","title":"Get slice of page","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Fields:</p> field type description page pdfplumber.page.Page The page to cut x0 float or int The x axis where the slice will start x1 float or int The x axis where the slice will terminate y0 float or int The y axis where the slice will start y1 float or int The y axis where the slice will terminate <p>When the above fields are populated, the <code>@slice</code> property describes the area of the page that will be used to extract text from.</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>class PageCut(NamedTuple):\n\"\"\"Fields:\n    field | type | description\n    --:|:--|:--\n    page | pdfplumber.page.Page | The page to cut\n    x0 | float or int | The x axis where the slice will start\n    x1 | float or int | The x axis where the slice will terminate\n    y0 | float or int | The y axis where the slice will start\n    y1 | float or int | The y axis where the slice will terminate\n    When the above fields are populated, the `@slice` property describes\n    the area of the page that will be used to extract text from.\n    \"\"\"\npage: Page\nx0: float | int\nx1: float | int\ny0: float | int\ny1: float | int\n@property\ndef slice(self) -&gt; CroppedPage:\n\"\"\"Unlike slicing from an image based on a `numpy.ndarray`, a page cut\n        implies a page derived from `pdfplumber`. The former is based on pixels;\n        the latter on points.\n        Examples:\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n            &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n            &gt;&gt;&gt; page, im = get_page_and_img(x, 0) # page 1\n            &gt;&gt;&gt; page.height\n            948.72\n            &gt;&gt;&gt; cutpage = PageCut(page=page, x0=100, x1=200, y0=100, y1=200).slice\n            &gt;&gt;&gt; cutpage.height\n            100\n            &gt;&gt;&gt; page.pdf.close()\n        Returns:\n            CroppedPage: The page crop where to extract text from.\n        \"\"\"\nbox: T_bbox = (self.x0, self.y0, self.x1, self.y1)\nreturn self.page.crop(box, relative=False, strict=True)\n@classmethod\ndef set(cls, page: Page, y0: float | int, y1: float | int) -&gt; CroppedPage:\n\"\"\"Using a uniform margin on the x-axis, supply the page\n        to generate page width and thus force preset margins. The `y0`\n        and `y1` fields determine how to slice the page.\n        Examples:\n            &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n            &gt;&gt;&gt; page, im = get_page_and_img(x, 1) # page 2\n            &gt;&gt;&gt; crop = PageCut.set(page, y0=0, y1=page.height * 0.1)\n            &gt;&gt;&gt; crop.extract_text()\n            'Resolution 2 A.M. No. P-14-3182'\n            &gt;&gt;&gt; page.pdf.close()\n        Args:\n            page (Page): pdfplumber Page object\n            y0 (float | int): Top y-axis\n            y1 (float | int): Bottom y-axis\n        Returns:\n            CroppedPage: The page crop where to extract text from.\n        \"\"\"\nSIDE_MARGIN = 50\nx0, x1 = SIDE_MARGIN, page.width - SIDE_MARGIN\nreturn cls(page=page, x0=x0, x1=x1, y0=y0, y1=y1).slice\n</code></pre>"},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut-attributes","title":"Attributes","text":""},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut.slice","title":"<code>slice: CroppedPage</code>  <code>property</code>","text":"<p>Unlike slicing from an image based on a <code>numpy.ndarray</code>, a page cut implies a page derived from <code>pdfplumber</code>. The former is based on pixels; the latter on points.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 0) # page 1\n&gt;&gt;&gt; page.height\n948.72\n&gt;&gt;&gt; cutpage = PageCut(page=page, x0=100, x1=200, y0=100, y1=200).slice\n&gt;&gt;&gt; cutpage.height\n100\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Returns:</p> Name Type Description <code>CroppedPage</code> <code>CroppedPage</code> <p>The page crop where to extract text from.</p>"},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut-functions","title":"Functions","text":""},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut.set","title":"<code>set(page, y0, y1)</code>  <code>classmethod</code>","text":"<p>Using a uniform margin on the x-axis, supply the page to generate page width and thus force preset margins. The <code>y0</code> and <code>y1</code> fields determine how to slice the page.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 1) # page 2\n&gt;&gt;&gt; crop = PageCut.set(page, y0=0, y1=page.height * 0.1)\n&gt;&gt;&gt; crop.extract_text()\n'Resolution 2 A.M. No. P-14-3182'\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>pdfplumber Page object</p> required <code>y0</code> <code>float | int</code> <p>Top y-axis</p> required <code>y1</code> <code>float | int</code> <p>Bottom y-axis</p> required <p>Returns:</p> Name Type Description <code>CroppedPage</code> <code>CroppedPage</code> <p>The page crop where to extract text from.</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>@classmethod\ndef set(cls, page: Page, y0: float | int, y1: float | int) -&gt; CroppedPage:\n\"\"\"Using a uniform margin on the x-axis, supply the page\n    to generate page width and thus force preset margins. The `y0`\n    and `y1` fields determine how to slice the page.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 1) # page 2\n        &gt;&gt;&gt; crop = PageCut.set(page, y0=0, y1=page.height * 0.1)\n        &gt;&gt;&gt; crop.extract_text()\n        'Resolution 2 A.M. No. P-14-3182'\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        page (Page): pdfplumber Page object\n        y0 (float | int): Top y-axis\n        y1 (float | int): Bottom y-axis\n    Returns:\n        CroppedPage: The page crop where to extract text from.\n    \"\"\"\nSIDE_MARGIN = 50\nx0, x1 = SIDE_MARGIN, page.width - SIDE_MARGIN\nreturn cls(page=page, x0=x0, x1=x1, y0=y0, y1=y1).slice\n</code></pre>"}]}