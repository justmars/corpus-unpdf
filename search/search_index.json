{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"corpus-unpdf Docs","text":"<p>PDF, as a file format, is the bane of programmatic text analysis.</p> <p>It's not a document format like <code>.txt</code>, <code>.docx</code>, <code>.md</code>, etc. where elements of a document such as (a) layout, (b) words, (c) lines, etc. can be extracted easily.</p> <p>Instead, PDFs can be equated to instructions producing human-comprehensible, yet machine-confusing outputs.</p> <p>Humans can eyeball these outputs and understand the result. Machines however can only parse and make a guess as to its contents. Put another way:</p> <p>Note</p> <p>PDF = humans good, machines bad</p> <p>In light of this context, this library is an attempt to parse Philippine Supreme Court decisions issued in PDF format and extract its raw \"as guessed\" output.</p>"},{"location":"#setup","title":"Setup","text":""},{"location":"#common-libraries","title":"Common libraries","text":"<p>Install common libraries in MacOS with <code>homebrew</code>:</p> Bash<pre><code>brew install tesseract\nbrew install imagemagick\nbrew info imagemagick # check version\n</code></pre> <p>The last command gets you the local folder installed which will be needed in creating the virtual environment:</p> Text Only<pre><code>==&gt; imagemagick: stable 7.1.0-59 (bottled), HEAD\nTools and libraries to manipulate images in many formats\nhttps://imagemagick.org/index.php\n/opt/homebrew/Cellar/imagemagick/7.1.0-60 (807 files, 31MB) * &lt;---- first part is the local folder\nx x x\n</code></pre> <p>Note that both <code>tesseract</code> and <code>imagemagick</code> libraries are also made preconditions in <code>.github/workflows/main.yaml</code>:</p> YAML<pre><code>steps:\n# see https://github.com/madmaze/pytesseract/blob/master/.github/workflows/ci.yaml\n- name: Install tesseract\nrun: sudo apt-get -y update &amp;&amp; sudo apt-get install -y tesseract-ocr tesseract-ocr-fra\n- name: Print tesseract version\nrun: echo $(tesseract --version)\n# see https://github.com/jsvine/pdfplumber/blob/stable/.github/workflows/tests.yml\n- name: Install ghostscript &amp; imagemagick\nrun: sudo apt update &amp;&amp; sudo apt install ghostscript libmagickwand-dev\n- name: Remove policy.xml\nrun: sudo rm /etc/ImageMagick-6/policy.xml # this needs to be removed or the test won't run\n</code></pre>"},{"location":"#virtual-environment","title":"Virtual environment","text":"<p>Update <code>.env</code> whenever <code>imagemagick</code> changes</p> <p>The shared dependency is based on <code>MAGICK_HOME</code> folder. This can't seem to be fetched by python (at least in 3.11) so we need to help it along by explicitly declaring its location. The folder can change when a new version is installed via <code>brew upgrade imagemagick</code></p> <p>Create an .env file and use the folder as the environment variable <code>MAGICK_HOME</code>:</p> Text Only<pre><code>MAGICK_HOME=/opt/homebrew/Cellar/imagemagick/7.1.0-60\n</code></pre> <p>This configuration will allow <code>pdfplumber</code> to detect <code>imagemagick</code>.</p> <p>Effect of not setting <code>MAGICK_HOME</code>:</p> Python<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; pdfplumber.open&lt;(testpath&gt;).pages[0].to_image(resolution=300) # ERROR\n</code></pre> Text Only<pre><code>OSError: cannot find library; tried paths: []\n\nDuring handling of the above exception, another exception occurred:\n\nImportError                               Traceback (most recent call last)\n...\nImportError: MagickWand shared library not found.\nYou probably had not installed ImageMagick library.\nTry to install:\n  brew install freetype imagemagick\n</code></pre> <p>With <code>MAGICK_HOME</code>:</p> Python<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; pdfplumber.open&lt;(testpath&gt;).pages[0].to_image\nPIL.Image.Image # image library and type detected\n</code></pre> <p>Proceed to create the environment using <code>poetry update</code> which will install the following into a separate virtual environment:</p> TOML<pre><code>[tool.poetry.dependencies]\npython = \"^3.11\"\npython-dotenv = \"^0.21\"\npdfplumber = \"^0.7.6\" # from pdf to txt\npillow = \"^9.4.0\" # from pdf to img\nopencv-python = \"^4.7.0.68\" # img manipulation\npytesseract = \"^0.3.10\" # map manipulated img\n</code></pre>"},{"location":"markers/","title":"Markers","text":"<p>Typically used in the first page of a Decision document to determine the positions of Y-coordinates and to extract the metadata associated with the page.</p>"},{"location":"markers/#court-composition","title":"Court Composition","text":""},{"location":"markers/#composition-choices","title":"Composition Choices","text":"<p>         Bases: <code>Enum</code></p> <p>How the Supreme Court sits. At present, this includes four options. Might need to add cases for special divisions.</p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class CourtCompositionChoices(Enum):\n\"\"\"How the Supreme Court sits. At present, this includes four\n    options. Might need to add cases for _special_ divisions.\"\"\"\nENBANC = \"En Banc\"\nDIV1 = \"First Division\"\nDIV2 = \"Second Division\"\nDIV3 = \"Third Division\"\n</code></pre>"},{"location":"markers/#extract-composition","title":"Extract Composition","text":"<p>         Bases: <code>NamedTuple</code></p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class PositionCourtComposition(NamedTuple):\nelement: CourtCompositionChoices\ncoordinates: tuple[int, int, int, int]\ncomposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in CourtCompositionChoices:\nif xywh := get_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\ncomposition_pct_height=(y + h) / im_h,\n)\nreturn None\n</code></pre>"},{"location":"markers/#decision-category-writer","title":"Decision Category &amp; Writer","text":""},{"location":"markers/#category-choices","title":"Category Choices","text":"<p>         Bases: <code>Enum</code></p> <p>The classification of a decision issued by the Supreme Court.</p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class DecisionCategoryChoices(Enum):\n\"\"\"The classification of a decision issued by the Supreme Court.\"\"\"\nCASO = \"Decision\"\nRESO = \"Resolution\"\n</code></pre>"},{"location":"markers/#extract-category","title":"Extract Category","text":"<p>         Bases: <code>NamedTuple</code></p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class PositionDecisionCategoryWriter(NamedTuple):\nelement: DecisionCategoryChoices\ncoordinates: tuple[int, int, int, int]\nwriter: str\ncategory_pct_height: float\nwriter_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in DecisionCategoryChoices:\nif xywh := get_centered_coordinates(im, member.value):\n_, y, _, h = xywh\ny0, y1 = y + h, y + 270\nwriter_box = im[y0:y1]\nreturn cls(\nelement=member,\ncoordinates=xywh,\nwriter=pytesseract.image_to_string(writer_box).strip(),\ncategory_pct_height=y / im_h,\nwriter_pct_height=y1 / im_h,\n)\nreturn None\n</code></pre>"},{"location":"markers/#notice","title":"Notice","text":"<p>         Bases: <code>NamedTuple</code></p> <p>When present, signifies that this was issued by authority of the Court.</p> Source code in <code>corpus_unpdf/src/markers.py</code> Python<pre><code>class PositionNotice(NamedTuple):\n\"\"\"When present, signifies that this was issued by authority of the Court.\"\"\"\nelement: NoticeChoices\ncoordinates: tuple[int, int, int, int]\nposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in NoticeChoices:\nif xywh := get_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\nposition_pct_height=(y + h) / im_h,\n)\nreturn None\n</code></pre>"},{"location":"pages/","title":"Pages","text":""},{"location":"pages/#decision","title":"Decision","text":"<p>Metadata of a pdf file parsed via <code>get_decision()</code></p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@dataclass\nclass Decision:\n\"\"\"Metadata of a pdf file parsed via `get_decision()`\"\"\"\nheader: CroppedPage\ncomposition: CourtCompositionChoices\nwriter: str | None = None\ncategory: DecisionCategoryChoices | None = None\nnotice: bool = False\npages: list[DecisionPage] = field(default_factory=list)\n@property\ndef lines(self) -&gt; Iterator[Bodyline]:\nfor page in self.pages:\nyield from page.lines\n@property\ndef notes(self) -&gt; Iterator[Footnote]:\nfor page in self.pages:\nyield from page.footnotes\n@classmethod\ndef make_start_page(\ncls,\npage: Page,\nim: numpy.ndarray,\nstart: PositionCourtComposition,\n) -&gt; Self | None:\n\"\"\"The first page can either be a:\n        1. regular `Decision` page which contains a `writer`, `category`, and `header`;\n        2. a `Notice` page which will be marked by a `notice`.\n        Args:\n            page (Page): The pdfplumber variant of the first page\n            im (numpy.ndarray): Image of the `page` that will help us get a page's\n                end points `e1` and `e2`\n            start (PositionCourtComposition): The previously found y-axis\n                based component for slicing the `page`'s `im`\n        Returns:\n            Self | None: A Decision instance with the first page included.\n        \"\"\"\ncut = {\"page\": page, \"x0\": SIDE_MARGIN, \"x1\": page.width - SIDE_MARGIN}\nhead = start.composition_pct_height * page.height\ne1, e2 = get_annex_y_axis(im, page)\nif ntc := PositionNotice.extract(im):\nnotice_pos = ntc.position_pct_height * page.height\nbody = PageCut(**cut, y0=notice_pos, y1=e1).slice\nannex = PageCut(**cut, y0=e1, y1=e2).slice if e2 else None\nreturn cls(\nnotice=True,\ncomposition=start.element,\nheader=PageCut(**cut, y0=head, y1=notice_pos).slice,\npages=[DecisionPage(page_num=1, body=body, annex=annex)],\n)\nelif category := PositionDecisionCategoryWriter.extract(im):\ncat_pos = category.category_pct_height * page.height\nwriter_pos = category.writer_pct_height * page.height\nbody = PageCut(**cut, y0=writer_pos, y1=e1).slice\nannex = PageCut(**cut, y0=e1, y1=e2).slice if e2 else None\nreturn cls(\ncomposition=start.element,\ncategory=category.element,\nwriter=category.writer,\nheader=PageCut(**cut, y0=head, y1=cat_pos).slice,\npages=[DecisionPage(page_num=1, body=body, annex=annex)],\n)\nreturn None\ndef make_next_pages(self, path: Path, last_num: int, last_y: int) -&gt; Self:\n\"\"\"After the first page is created, add subsequent pages taking into\n        account the terminal page and line. When the terminal page `last_num`\n        is reached, stop the for-loop.\n        Args:\n            path (Path): Path to the pdf file.\n            last_num (int): The terminal page\n            last_y (int): The y-axis point of the terminal page\n        Returns:\n            Self: The Decision instance containing any added pages from\n            the for loop.\n        \"\"\"\nfor page in pdfplumber.open(path).pages:\nif (num := page.page_number) != 1:\nif num == last_num:\nself.pages.append(DecisionPage.extract(path, num, last_y))\nbreak\nelse:\nself.pages.append(DecisionPage.extract(path, num))\nreturn self\n</code></pre>"},{"location":"pages/#corpus_unpdf.Decision-functions","title":"Functions","text":""},{"location":"pages/#corpus_unpdf.decision.Decision.make_next_pages","title":"<code>make_next_pages(path, last_num, last_y)</code>","text":"<p>After the first page is created, add subsequent pages taking into account the terminal page and line. When the terminal page <code>last_num</code> is reached, stop the for-loop.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <code>last_num</code> <code>int</code> <p>The terminal page</p> required <code>last_y</code> <code>int</code> <p>The y-axis point of the terminal page</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The Decision instance containing any added pages from</p> <code>Self</code> <p>the for loop.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def make_next_pages(self, path: Path, last_num: int, last_y: int) -&gt; Self:\n\"\"\"After the first page is created, add subsequent pages taking into\n    account the terminal page and line. When the terminal page `last_num`\n    is reached, stop the for-loop.\n    Args:\n        path (Path): Path to the pdf file.\n        last_num (int): The terminal page\n        last_y (int): The y-axis point of the terminal page\n    Returns:\n        Self: The Decision instance containing any added pages from\n        the for loop.\n    \"\"\"\nfor page in pdfplumber.open(path).pages:\nif (num := page.page_number) != 1:\nif num == last_num:\nself.pages.append(DecisionPage.extract(path, num, last_y))\nbreak\nelse:\nself.pages.append(DecisionPage.extract(path, num))\nreturn self\n</code></pre>"},{"location":"pages/#corpus_unpdf.decision.Decision.make_start_page","title":"<code>make_start_page(page, im, start)</code>  <code>classmethod</code>","text":"<p>The first page can either be a:</p> <ol> <li>regular <code>Decision</code> page which contains a <code>writer</code>, <code>category</code>, and <code>header</code>;</li> <li>a <code>Notice</code> page which will be marked by a <code>notice</code>.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>The pdfplumber variant of the first page</p> required <code>im</code> <code>numpy.ndarray</code> <p>Image of the <code>page</code> that will help us get a page's end points <code>e1</code> and <code>e2</code></p> required <code>start</code> <code>PositionCourtComposition</code> <p>The previously found y-axis based component for slicing the <code>page</code>'s <code>im</code></p> required <p>Returns:</p> Type Description <code>Self | None</code> <p>Self | None: A Decision instance with the first page included.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@classmethod\ndef make_start_page(\ncls,\npage: Page,\nim: numpy.ndarray,\nstart: PositionCourtComposition,\n) -&gt; Self | None:\n\"\"\"The first page can either be a:\n    1. regular `Decision` page which contains a `writer`, `category`, and `header`;\n    2. a `Notice` page which will be marked by a `notice`.\n    Args:\n        page (Page): The pdfplumber variant of the first page\n        im (numpy.ndarray): Image of the `page` that will help us get a page's\n            end points `e1` and `e2`\n        start (PositionCourtComposition): The previously found y-axis\n            based component for slicing the `page`'s `im`\n    Returns:\n        Self | None: A Decision instance with the first page included.\n    \"\"\"\ncut = {\"page\": page, \"x0\": SIDE_MARGIN, \"x1\": page.width - SIDE_MARGIN}\nhead = start.composition_pct_height * page.height\ne1, e2 = get_annex_y_axis(im, page)\nif ntc := PositionNotice.extract(im):\nnotice_pos = ntc.position_pct_height * page.height\nbody = PageCut(**cut, y0=notice_pos, y1=e1).slice\nannex = PageCut(**cut, y0=e1, y1=e2).slice if e2 else None\nreturn cls(\nnotice=True,\ncomposition=start.element,\nheader=PageCut(**cut, y0=head, y1=notice_pos).slice,\npages=[DecisionPage(page_num=1, body=body, annex=annex)],\n)\nelif category := PositionDecisionCategoryWriter.extract(im):\ncat_pos = category.category_pct_height * page.height\nwriter_pos = category.writer_pct_height * page.height\nbody = PageCut(**cut, y0=writer_pos, y1=e1).slice\nannex = PageCut(**cut, y0=e1, y1=e2).slice if e2 else None\nreturn cls(\ncomposition=start.element,\ncategory=category.element,\nwriter=category.writer,\nheader=PageCut(**cut, y0=head, y1=cat_pos).slice,\npages=[DecisionPage(page_num=1, body=body, annex=annex)],\n)\nreturn None\n</code></pre>"},{"location":"pages/#decisionpage","title":"DecisionPage","text":"<p>Each <code>page_num</code> should have a <code>body</code>, and optionally an <code>annex</code>.</p> <p><code>lines</code>  are segments of the body's text (in the given page num); segments are split based on regex.</p> <p><code>footnotes</code> refer to each item in the annex's text (in the given page num); footnote splitting is based on regex.</p> <p>Returns:</p> Name Type Description <code>DecisionPage</code> <p>Page with individual components mapped out.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@dataclass\nclass DecisionPage:\n\"\"\"Each `page_num` should have a `body`, and optionally an `annex`.\n    `lines`  are segments of the body's text (in the given page\n    num); segments are split based on regex.\n    `footnotes` refer to each item in the annex's text (in the given page\n    num); footnote splitting is based on regex.\n    Returns:\n        DecisionPage: Page with individual components mapped out.\n    \"\"\"\npage_num: int\nbody: CroppedPage\nannex: CroppedPage | None = None\nlines: list[Bodyline] = field(default_factory=list)\nfootnotes: list[Footnote] = field(default_factory=list)\ndef __post_init__(self):\nself.lines = Bodyline.from_cropped(self.body)\nif self.annex:\nself.footnotes = Footnote.from_cropped(self.annex)\n@classmethod\ndef extract(\ncls,\npath: Path,\npage_num: int = 2,\nterminal_y: int | None = None,\n) -&gt; Self:\n\"\"\"Each non-first page follows a certain format.\n        Args:\n            path (Path): Path to the pdf file.\n            page_num (int, optional): Will deduct 1 for slicing. Defaults to 2.\n            terminal_y (int | None, optional): If present, refers to\n                The y-axis point of the terminal page. Defaults to None.\n        Returns:\n            Self: A component page element of a Decision.\n        \"\"\"\nif page_num &lt;= 1:\nraise Exception(\"Must not be the first page.\")\npage, im = get_page_and_img(path, page_num - 1)\ncut = {\"page\": page, \"x0\": SIDE_MARGIN, \"x1\": page.width - SIDE_MARGIN}\nhead = get_header_terminal(im, page)\nif not head:\nraise Exception(\"Could not find header.\")\ne1, e2 = get_annex_y_axis(im, page)\nannex = PageCut(**cut, y0=e1, y1=e2).slice if e2 else None\nif terminal_y:\ne1 = terminal_y\nreturn cls(\nbody=PageCut(**cut, y0=head, y1=e1).slice,\nannex=annex,\npage_num=page_num,\n)\n</code></pre>"},{"location":"pages/#corpus_unpdf.DecisionPage-functions","title":"Functions","text":""},{"location":"pages/#corpus_unpdf.decision.DecisionPage.extract","title":"<code>extract(path, page_num=2, terminal_y=None)</code>  <code>classmethod</code>","text":"<p>Each non-first page follows a certain format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <code>page_num</code> <code>int</code> <p>Will deduct 1 for slicing. Defaults to 2.</p> <code>2</code> <code>terminal_y</code> <code>int | None</code> <p>If present, refers to The y-axis point of the terminal page. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A component page element of a Decision.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@classmethod\ndef extract(\ncls,\npath: Path,\npage_num: int = 2,\nterminal_y: int | None = None,\n) -&gt; Self:\n\"\"\"Each non-first page follows a certain format.\n    Args:\n        path (Path): Path to the pdf file.\n        page_num (int, optional): Will deduct 1 for slicing. Defaults to 2.\n        terminal_y (int | None, optional): If present, refers to\n            The y-axis point of the terminal page. Defaults to None.\n    Returns:\n        Self: A component page element of a Decision.\n    \"\"\"\nif page_num &lt;= 1:\nraise Exception(\"Must not be the first page.\")\npage, im = get_page_and_img(path, page_num - 1)\ncut = {\"page\": page, \"x0\": SIDE_MARGIN, \"x1\": page.width - SIDE_MARGIN}\nhead = get_header_terminal(im, page)\nif not head:\nraise Exception(\"Could not find header.\")\ne1, e2 = get_annex_y_axis(im, page)\nannex = PageCut(**cut, y0=e1, y1=e2).slice if e2 else None\nif terminal_y:\ne1 = terminal_y\nreturn cls(\nbody=PageCut(**cut, y0=head, y1=e1).slice,\nannex=annex,\npage_num=page_num,\n)\n</code></pre>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#fetch-pdfs","title":"Fetch PDFs","text":"<p>Work with pdf files.</p>"},{"location":"utils/#extract-page-image","title":"Extract page, image","text":"<p>Combines <code>OpenCV</code> with <code>pdfplumber</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 0) # 0 marks the first page\n&gt;&gt;&gt; page.page_number # the first page\n1\n&gt;&gt;&gt; isinstance(page, Page)\nTrue\n&gt;&gt;&gt; isinstance(im, numpy.ndarray)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>str | Path</code> <p>Path to the PDF file.</p> required <code>index</code> <code>int</code> <p>Zero-based index that determines the page number.</p> required <p>Returns:</p> Type Description <code>tuple[Page, numpy.ndarray]</code> <p>tuple[Page, numpy.ndarray]: Page identified by <code>index</code>  with image of the page  (in numpy format) that can be manipulated.</p> Source code in <code>corpus_unpdf/src/common/fetch.py</code> Python<pre><code>def get_page_and_img(\npdfpath: str | Path, index: int\n) -&gt; tuple[Page, numpy.ndarray]:\n\"\"\"Combines `OpenCV` with `pdfplumber`.\n    Examples:\n        &gt;&gt;&gt; import numpy\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 0) # 0 marks the first page\n        &gt;&gt;&gt; page.page_number # the first page\n        1\n        &gt;&gt;&gt; isinstance(page, Page)\n        True\n        &gt;&gt;&gt; isinstance(im, numpy.ndarray)\n        True\n    Args:\n        pdfpath (str | Path): Path to the PDF file.\n        index (int): Zero-based index that determines the page number.\n    Returns:\n        tuple[Page, numpy.ndarray]: Page identified by `index`  with image of the\n            page  (in numpy format) that can be manipulated.\n    \"\"\"\npdf = pdfplumber.open(pdfpath)\npage = pdf.pages[index]\nimg = get_img_from_page(page)\nreturn page, img\n</code></pre>"},{"location":"utils/#reverse-list-pages-images","title":"Reverse list pages, images","text":"<p>Start from the end page to get to the first page to determine terminal values.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; results = get_reverse_pages_and_imgs(x)\n&gt;&gt;&gt; result = next(results)\n&gt;&gt;&gt; type(result)\n&lt;class 'tuple'&gt;\n&gt;&gt;&gt; isinstance(result[0], Page)\nTrue\n&gt;&gt;&gt; assert result[0].page_number == len(pdfplumber.open(x).pages) # last first\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>str | Path</code> <p>Path to the PDF file.</p> required <p>Yields:</p> Type Description <code>Iterator[tuple[Page, numpy.ndarray]]</code> <p>Iterator[tuple[Page, numpy.ndarray]]: Pages with respective images</p> Source code in <code>corpus_unpdf/src/common/fetch.py</code> Python<pre><code>def get_reverse_pages_and_imgs(\npdfpath: str | Path,\n) -&gt; Iterator[tuple[Page, numpy.ndarray]]:\n\"\"\"Start from the end page to get to the first page\n    to determine terminal values.\n    Examples:\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; results = get_reverse_pages_and_imgs(x)\n        &gt;&gt;&gt; result = next(results)\n        &gt;&gt;&gt; type(result)\n        &lt;class 'tuple'&gt;\n        &gt;&gt;&gt; isinstance(result[0], Page)\n        True\n        &gt;&gt;&gt; assert result[0].page_number == len(pdfplumber.open(x).pages) # last first\n    Args:\n        pdfpath (str | Path): Path to the PDF file.\n    Yields:\n        Iterator[tuple[Page, numpy.ndarray]]: Pages with respective images\n    \"\"\"\npdf = pdfplumber.open(pdfpath)\nindex = len(pdf.pages) - 1\nwhile True:\npage = pdf.pages[index]\nyield page, get_img_from_page(page)\nif index == 0:\nbreak\nindex -= 1\n</code></pre>"},{"location":"utils/#slice-images-pages","title":"Slice images &amp; pages","text":"<p>Using pre-processed PDF files above, slice images and/or pages based on certain criteria.</p>"},{"location":"utils/#get-contours-from-image","title":"Get contours from image","text":"<p>Generally follows the strategy outlined here:</p> <ol> <li>Youtube video</li> <li>Stack Overflow answer</li> </ol> <p>The structuring element used will be a rectangle of dimensions specified in <code>rectangle_size</code>. After dilating the image, the contours can be enumerated for further processing and matching, e.g. after the image is transformed, can find which lines appear in the center or in the top right quadrant, etc.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>numpy.ndarray</code> <p>The opencv formatted image</p> required <code>rectangle_size</code> <code>tuple[int, int]</code> <p>The width and height to morph the characters</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The contours found based on the specified structuring element</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>def get_contours(img: numpy.ndarray, rectangle_size: tuple[int, int]) -&gt; list:\n\"\"\"Generally follows the strategy outlined here:\n    1. [Youtube video](https://www.youtube.com/watch?v=ZeCRe9sNFwk&amp;list=PL2VXyKi-KpYuTAZz__9KVl1jQz74bDG7i&amp;index=11)\n    2. [Stack Overflow answer](https://stackoverflow.com/a/57262099)\n    The structuring element used will be a rectangle of dimensions\n    specified in `rectangle_size`. After dilating the image,\n    the contours can be enumerated for further processing and\n    matching, e.g. after the image is transformed, can find\n    which lines appear in the center or in the top right quadrant, etc.\n    Args:\n        img (numpy.ndarray): The opencv formatted image\n        rectangle_size (tuple[int, int]): The width and height to morph the characters\n    Returns:\n        list: The contours found based on the specified structuring element\n    \"\"\"  # noqa: E501\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray, (7, 7), 0)\nthresh = cv2.threshold(\nblur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU\n)[1]\nkernel = cv2.getStructuringElement(cv2.MORPH_RECT, rectangle_size)\ndilate = cv2.dilate(thresh, kernel, iterations=1)\ncv2.imwrite(\"temp/sample_dilated.png\", dilate)\ncnts = cv2.findContours(dilate, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\ncnts = cnts[0] if len(cnts) == 2 else cnts[1]\nreturn sorted(cnts, key=lambda x: cv2.boundingRect(x)[1])\n</code></pre>"},{"location":"utils/#centered-text-matching-contours","title":"Centered text matching contours","text":"<p>With a image <code>im</code>, get all contours found in the center of the image and then for each of these matches, if they are text resembling <code>text_to_match</code>, extract the coordinates of such contours.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 0)\n&gt;&gt;&gt; get_centered_coordinates(im, 'Decision') # None found\n&gt;&gt;&gt; get_centered_coordinates(im, 'Resolution')\n(1043, 2118, 614, 72)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The base image to look for text</p> required <code>text_to_match</code> <code>str</code> <p>The words that should match</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int, int] | None</code> <p>tuple[int, int, int, int] | None: (x, y, w, h) pixels representing <code>cv2.boundingRect</code>, if found.</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>def get_centered_coordinates(\nim: numpy.ndarray, text_to_match: str\n) -&gt; tuple[int, int, int, int] | None:\n\"\"\"With a image `im`, get all contours found in the center\n    of the image and then for each of these matches, if they\n    are text resembling `text_to_match`, extract the coordinates of\n    such contours.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 0)\n        &gt;&gt;&gt; get_centered_coordinates(im, 'Decision') # None found\n        &gt;&gt;&gt; get_centered_coordinates(im, 'Resolution')\n        (1043, 2118, 614, 72)\n    Args:\n        im (numpy.ndarray): The base image to look for text\n        text_to_match (str): The words that should match\n    Returns:\n        tuple[int, int, int, int] | None: (x, y, w, h) pixels representing\n            `cv2.boundingRect`, if found.\n    \"\"\"\n_, im_w, _ = im.shape\ncnts = get_contours(im, (100, 30))\nfor cnt in cnts:\nx, y, w, h = cv2.boundingRect(cnt)\nif is_centered(im_w, x, w):\nsliced_im = im[y : y + h, x : x + w]\nif sliced_txt := pytesseract.image_to_string(sliced_im):\ntxt_a = text_to_match.upper()\ntxt_b = sliced_txt.upper()\nif SequenceMatcher(None, a=txt_a, b=txt_b).ratio() &gt; 0.7:\nreturn x, y, w, h\nreturn None\n</code></pre>"},{"location":"utils/#get-slice-of-page","title":"Get slice of page","text":"<p>Note the two kinds of measurements involved.</p> <p>A <code>page</code>  is based on <code>pdfplumber</code>'s points.</p> <p>An <code>image</code> is based on pixels.</p> <p>In order to use the image's pixels as page points, use the the image's max width / height as the divisor to get the ratio and then apply that ratio (percentage) to the page's max width / height. See related answer</p> <p>         Bases: <code>NamedTuple</code></p> <p>Fields:</p> field type description page pdfplumber.page.Page The page to cut x0 float or int The x axis where the slice will start x1 float or int The x axis where the slice will terminate y0 float or int The y axis where the slice will start y1 float or int The y axis where the slice will terminate <p>When the above fields are populated, the <code>@slice</code> property describes the area of the page that will be used to extract text from.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 0)\n&gt;&gt;&gt; page.height\n948.72\n&gt;&gt;&gt; cutpage = PageCut(page=page, x0=100, x1=200, y0=100, y1=200).slice\n&gt;&gt;&gt; cutpage.height\n100\n</code></pre> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>class PageCut(NamedTuple):\n\"\"\"Fields:\n    field | type | description\n    --:|:--|:--\n    page | pdfplumber.page.Page | The page to cut\n    x0 | float or int | The x axis where the slice will start\n    x1 | float or int | The x axis where the slice will terminate\n    y0 | float or int | The y axis where the slice will start\n    y1 | float or int | The y axis where the slice will terminate\n    When the above fields are populated, the `@slice` property describes\n    the area of the page that will be used to extract text from.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 0)\n        &gt;&gt;&gt; page.height\n        948.72\n        &gt;&gt;&gt; cutpage = PageCut(page=page, x0=100, x1=200, y0=100, y1=200).slice\n        &gt;&gt;&gt; cutpage.height\n        100\n    \"\"\"\npage: Page\nx0: float | int\nx1: float | int\ny0: float | int\ny1: float | int\n@property\ndef slice(self) -&gt; CroppedPage:\n\"\"\"Unlike slicing from an image based on a `numpy.ndarray`, a page cut\n        implies a page derived from `pdfplumber`. The former is based on pixels;\n        the latter on points.\n        Returns:\n            CroppedPage: The page crop where to extract text from.\n        \"\"\"\nbox: T_bbox = (self.x0, self.y0, self.x1, self.y1)\nreturn self.page.crop(box, relative=False, strict=True)\n</code></pre>"},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut-attributes","title":"Attributes","text":""},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut.slice","title":"<code>slice: CroppedPage</code>  <code>property</code>","text":"<p>Unlike slicing from an image based on a <code>numpy.ndarray</code>, a page cut implies a page derived from <code>pdfplumber</code>. The former is based on pixels; the latter on points.</p> <p>Returns:</p> Name Type Description <code>CroppedPage</code> <code>CroppedPage</code> <p>The page crop where to extract text from.</p>"}]}