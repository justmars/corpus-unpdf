{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"corpus-unpdf Docs","text":"<p>Apply image processing / OCR to main and separate opinions in the PH Supreme Court website.</p>"},{"location":"#mainopinionpages","title":"<code>MainOpinionPages</code>","text":"<p>         Bases: <code>Collection</code>, <code>FrontpageMeta</code></p> <p>The main opinion of a Decision or Resolution, specifically its front and last pages, is formatted differenly from separate opinions. The following metadata are required to be parsed:</p> <ol> <li>Composition, i.e. whether En Banc or by divison.</li> <li>Category, i.e. whether a Decision or a Resolution.</li> <li>Writer, i.e. who penned the main opinion.</li> <li>Notice, i.e. whether it is of a particular category of decisions.</li> </ol> <p>Given a PDF file, can use <code>MainOpinionPages.set(&lt;path-to-pdf)</code> to extract content pages and the above metadata of the file. The fields of this data structure inherits from <code>start_ocr</code>'s <code>Collection</code> with a custom <code>FrontpageMeta</code>.</p> Source code in <code>corpus_unpdf/main.py</code> Python<pre><code>@dataclass\nclass MainOpinionPages(Collection, FrontpageMeta):\n\"\"\"The main opinion of a _Decision_ or _Resolution_, specifically its front and last pages, is formatted differenly from [separate opinions][separateopinionpages]. The following metadata are required to be parsed:\n    1. [Composition][court-composition], i.e. whether _En Banc_ or by divison.\n    2. [Category][decision-category-writer], i.e. whether a _Decision_ or a _Resolution_.\n    2. [Writer][decision-category-writer], i.e. who penned the main opinion.\n    3. [Notice][notice], i.e. whether it is of a particular category of decisions.\n    Given a PDF file, can use `MainOpinionPages.set(&lt;path-to-pdf)` to extract content pages _and the above metadata_ of the file. The fields of this data structure inherits from `start_ocr`'s `Collection` with a custom `FrontpageMeta`.\n    \"\"\"  # noqa: E501\n...\n@classmethod\ndef set(cls, path: Path) -&gt; Self:\n\"\"\"From a _*.pdf_ file found in `path`, extract relevant metadata to generate a decision having content pages. Each of which will contain a body and, likely, an annex for footnotes.\n        Examples:\n            &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n            &gt;&gt;&gt; decision = MainOpinionPages.set(x)\n            &gt;&gt;&gt; decision.category\n            &lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n            &gt;&gt;&gt; decision.composition\n            &lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n            &gt;&gt;&gt; decision.writer\n            'CARPIO. J.:'\n            &gt;&gt;&gt; len(decision.pages) # total page count\n            5\n            &gt;&gt;&gt; from start_ocr import Bodyline, Footnote, Content\n            &gt;&gt;&gt; isinstance(decision.pages[0], Content) # first page\n            True\n            &gt;&gt;&gt; isinstance(decision.segments[0], Bodyline)\n            True\n            &gt;&gt;&gt; isinstance(decision.footnotes[0], Footnote)\n            True\n            &gt;&gt;&gt; len(decision.footnotes) # TODO: limited number detected; should be 15\n            10\n        \"\"\"  # noqa: E501\npos = PositionMeta.prep(path)\nwith pdfplumber.open(path) as pdf:\ncaso = cls._init(pdf=pdf, pos=pos)  # all pages\ncaso._limit_pages(pages=pdf.pages, pos=pos)  # limited pages\ncaso.join_segments()\ncaso.join_annexes()\nreturn caso\n@classmethod\ndef _init(cls, pdf: PDF, pos: PositionMeta) -&gt; Self:\n\"\"\"Extract first page of the content proper which may not necessarily be page 1.\n        Args:\n            pdf (PDF): The `pdfplumber`-formatted PDF\n            pos (PositionMeta): Contains true start and end position / pages\n        Returns:\n            Self: MainOpinionPages instance.\n        \"\"\"\nstart_page = pdf.pages[pos.start_index]\nif isinstance(pos.start_indicator, PositionNotice):\nreturn cls(\ncomposition=PositionCourtComposition.from_pdf(pdf).element,\nnotice=True,\npages=[\nContent.set(\npage=start_page,\nstart_y=pos.start_indicator.position_pct_height\n* start_page.height,\n)\n],\n)\nelif isinstance(pos.start_indicator, PositionDecisionCategoryWriter):\nreturn cls(\ncomposition=PositionCourtComposition.from_pdf(pdf).element,\ncategory=pos.start_indicator.element,\nwriter=pos.start_indicator.writer,\npages=[\nContent.set(\npage=start_page,\nstart_y=pos.start_indicator.writer_pct_height\n* start_page.height,\n)\n],\n)\nraise Exception(\"Unexpected initialization of decision.\")\ndef _limit_pages(self, pages: list[Page], pos: PositionMeta):\n\"\"\"Only add pages included in the `pos` metadata when generating the Decision collection.\"\"\"  # noqa: E501\nfor nxt in pages:\nif nxt.page_number &lt;= pos.start_page_num:\ncontinue\nif nxt.page_number == pos.end_page_num:\nlogger.debug(f\"Finalize {nxt.page_number=}.\")\nif page_valid := Content.set(page=nxt, end_y=pos.end_page_pos):\nself.pages.append(page_valid)\nelse:\nlogger.warning(\"Detected blank page.\")\nbreak\nelse:\nlogger.debug(f\"Initialize {nxt.page_number=}.\")\nif page_valid := Content.set(page=nxt):\nself.pages.append(page_valid)\nelse:\nlogger.warning(\"Detected blank page.\")\n</code></pre>"},{"location":"#corpus_unpdf.main.MainOpinionPages-functions","title":"Functions","text":""},{"location":"#corpus_unpdf.main.MainOpinionPages.set","title":"<code>set(path)</code>  <code>classmethod</code>","text":"<p>From a *.pdf file found in <code>path</code>, extract relevant metadata to generate a decision having content pages. Each of which will contain a body and, likely, an annex for footnotes.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; decision = MainOpinionPages.set(x)\n&gt;&gt;&gt; decision.category\n&lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n&gt;&gt;&gt; decision.composition\n&lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n&gt;&gt;&gt; decision.writer\n'CARPIO. J.:'\n&gt;&gt;&gt; len(decision.pages) # total page count\n5\n&gt;&gt;&gt; from start_ocr import Bodyline, Footnote, Content\n&gt;&gt;&gt; isinstance(decision.pages[0], Content) # first page\nTrue\n&gt;&gt;&gt; isinstance(decision.segments[0], Bodyline)\nTrue\n&gt;&gt;&gt; isinstance(decision.footnotes[0], Footnote)\nTrue\n&gt;&gt;&gt; len(decision.footnotes) # TODO: limited number detected; should be 15\n10\n</code></pre> Source code in <code>corpus_unpdf/main.py</code> Python<pre><code>@classmethod\ndef set(cls, path: Path) -&gt; Self:\n\"\"\"From a _*.pdf_ file found in `path`, extract relevant metadata to generate a decision having content pages. Each of which will contain a body and, likely, an annex for footnotes.\n    Examples:\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; decision = MainOpinionPages.set(x)\n        &gt;&gt;&gt; decision.category\n        &lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n        &gt;&gt;&gt; decision.composition\n        &lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n        &gt;&gt;&gt; decision.writer\n        'CARPIO. J.:'\n        &gt;&gt;&gt; len(decision.pages) # total page count\n        5\n        &gt;&gt;&gt; from start_ocr import Bodyline, Footnote, Content\n        &gt;&gt;&gt; isinstance(decision.pages[0], Content) # first page\n        True\n        &gt;&gt;&gt; isinstance(decision.segments[0], Bodyline)\n        True\n        &gt;&gt;&gt; isinstance(decision.footnotes[0], Footnote)\n        True\n        &gt;&gt;&gt; len(decision.footnotes) # TODO: limited number detected; should be 15\n        10\n    \"\"\"  # noqa: E501\npos = PositionMeta.prep(path)\nwith pdfplumber.open(path) as pdf:\ncaso = cls._init(pdf=pdf, pos=pos)  # all pages\ncaso._limit_pages(pages=pdf.pages, pos=pos)  # limited pages\ncaso.join_segments()\ncaso.join_annexes()\nreturn caso\n</code></pre>"},{"location":"#separateopinionpages","title":"<code>SeparateOpinionPages</code>","text":"<p>         Bases: <code>Collection</code></p> <p>Handles content and metadata of separate opinions, i.e. the concurring, dissenting opinions to a main opinion of a Decision or Resolution.</p> <p>Given a PDF file, can use <code>SeparateOpinionPages.set(&lt;path-to-pdf)</code> to extract content pages (only) of the file. The fields of this data structure inherits from <code>start_ocr</code>'s <code>Collection</code>.</p> Source code in <code>corpus_unpdf/main.py</code> Python<pre><code>@dataclass\nclass SeparateOpinionPages(Collection):\n\"\"\"Handles content and metadata of separate opinions, i.e. the concurring, dissenting opinions to a [main\n    opinion][mainopinionpages] of a _Decision_ or _Resolution_.\n    Given a PDF file, can use `SeparateOpinionPages.set(&lt;path-to-pdf)` to extract _content pages (only)_ of the file. The fields of this data structure inherits from `start_ocr`'s `Collection`.\n    \"\"\"  # noqa: E501\n...\n@classmethod\ndef set(cls, path: Path):\n\"\"\"Limited extraction: only interested in content unlike decisions where metadata is relevant. Also assumes first page will always be the logical start.\n        Examples:\n            &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"opinion.pdf\"\n            &gt;&gt;&gt; opinion = SeparateOpinionPages.set(x)\n            &gt;&gt;&gt; len(opinion.pages) # total page count\n            10\n            &gt;&gt;&gt; from start_ocr import Bodyline, Footnote, Content\n            &gt;&gt;&gt; isinstance(opinion.pages[0], Content) # first page\n            True\n            &gt;&gt;&gt; isinstance(opinion.segments[0], Bodyline)\n            True\n            &gt;&gt;&gt; isinstance(opinion.footnotes[0], Footnote)\n            True\n        \"\"\"  # noqa: E501\nfirst_page = Collection.preliminary_page(path)  # uses the sample execution\nreturn Collection.make(path, preliminary_page=first_page)\n</code></pre>"},{"location":"#corpus_unpdf.main.SeparateOpinionPages-functions","title":"Functions","text":""},{"location":"#corpus_unpdf.main.SeparateOpinionPages.set","title":"<code>set(path)</code>  <code>classmethod</code>","text":"<p>Limited extraction: only interested in content unlike decisions where metadata is relevant. Also assumes first page will always be the logical start.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"opinion.pdf\"\n&gt;&gt;&gt; opinion = SeparateOpinionPages.set(x)\n&gt;&gt;&gt; len(opinion.pages) # total page count\n10\n&gt;&gt;&gt; from start_ocr import Bodyline, Footnote, Content\n&gt;&gt;&gt; isinstance(opinion.pages[0], Content) # first page\nTrue\n&gt;&gt;&gt; isinstance(opinion.segments[0], Bodyline)\nTrue\n&gt;&gt;&gt; isinstance(opinion.footnotes[0], Footnote)\nTrue\n</code></pre> Source code in <code>corpus_unpdf/main.py</code> Python<pre><code>@classmethod\ndef set(cls, path: Path):\n\"\"\"Limited extraction: only interested in content unlike decisions where metadata is relevant. Also assumes first page will always be the logical start.\n    Examples:\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"opinion.pdf\"\n        &gt;&gt;&gt; opinion = SeparateOpinionPages.set(x)\n        &gt;&gt;&gt; len(opinion.pages) # total page count\n        10\n        &gt;&gt;&gt; from start_ocr import Bodyline, Footnote, Content\n        &gt;&gt;&gt; isinstance(opinion.pages[0], Content) # first page\n        True\n        &gt;&gt;&gt; isinstance(opinion.segments[0], Bodyline)\n        True\n        &gt;&gt;&gt; isinstance(opinion.footnotes[0], Footnote)\n        True\n    \"\"\"  # noqa: E501\nfirst_page = Collection.preliminary_page(path)  # uses the sample execution\nreturn Collection.make(path, preliminary_page=first_page)\n</code></pre>"},{"location":"markers/","title":"Markers","text":""},{"location":"markers/#metadata","title":"Metadata","text":"<p>Each document will have:</p> Page type Note start there will be a deliberate start y-axis position affected by markers. content see <code>start-ocr</code> \"primitives\" <code>Bodyline</code> for content segments, <code>Footnote</code> for discovered footnote partials. end there will be a deliberate end y-axis position. <p>Y-axis cutting</p> <p>The y-axis is relevant for start and end... since the header and the footer are cut out be to arrive at the meat of each page. And each page can then be dissected into segments and footnotes.</p> <p>Warning</p> <p>Not all markers are found in the preliminary page. Hence, need to find anchoring start of content.</p>"},{"location":"markers/#court-composition","title":"Court Composition","text":""},{"location":"markers/#composition-choices","title":"Composition Choices","text":"<p>         Bases: <code>Enum</code></p> <p>How Philippine Supreme Court sits. At present, this includes four options: en banc + 3 divisions. TODO: Might need to add cases for special divisions.</p> Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class CourtCompositionChoices(Enum):\n\"\"\"How Philippine Supreme Court sits. At present, this includes four options: en banc + 3 divisions. TODO: Might need to add cases for _special_ divisions.\"\"\"  # noqa: E501\nENBANC = \"En Banc\"\nDIV1 = \"First Division\"\nDIV2 = \"Second Division\"\nDIV3 = \"Third Division\"\n</code></pre>"},{"location":"markers/#extract-composition","title":"Extract Composition","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Should be present as top centered element in the first page of a Decision PDF file.</p> Field Type Description <code>element</code> CourtCompositionChoices Presently four choices <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the composition is found <code>composition_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class PositionCourtComposition(NamedTuple):\n\"\"\"Should be present as top centered element in the first page of a Decision PDF file.\n    Field | Type | Description\n    --:|:--:|:--\n    `element` | [CourtCompositionChoices][composition-choices] | Presently four choices\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the composition is found\n    `composition_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    \"\"\"  # noqa: E501\nelement: CourtCompositionChoices\ncoordinates: tuple[int, int, int, int]\ncomposition_pct_height: float\n@classmethod\ndef extract(cls, im: np.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in CourtCompositionChoices:\nif xywh := get_likelihood_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\ncomposition_pct_height=(y + h) / im_h,\n)\nreturn None\n@classmethod\ndef from_pdf(cls, pdf: PDF) -&gt; Self:\npage_one_im = get_img_from_page(pdf.pages[0])\ncourt_composition = cls.extract(page_one_im)\nif not court_composition:\nraise Exception(\"Could not detect court compositon in page 1.\")\nreturn court_composition\n</code></pre>"},{"location":"markers/#decision-category-writer","title":"Decision Category &amp; Writer","text":""},{"location":"markers/#category-choices","title":"Category Choices","text":"<p>         Bases: <code>Enum</code></p> <p>The classification of a decision issued by the Supreme Court, i.e. a decision or a resolution.</p> Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class DecisionCategoryChoices(Enum):\n\"\"\"The classification of a decision issued by the Supreme Court, i.e.\n    a decision or a resolution.\"\"\"\nCASO = \"Decision\"\nRESO = \"Resolution\"\n</code></pre>"},{"location":"markers/#extract-category","title":"Extract Category","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Should be present as top centered element in the first page of a Decision PDF file.</p> Field Type Description <code>element</code> DecisionCategoryChoices Presently four choices <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the <code>composition</code> element is found <code>writer</code> str The string found indicating the name of the writer <code>category_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. <code>writer_pct_height</code> float The writer's coordinates are found below the category coordinates. This can then be used to signify the anchoring start of the document. Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class PositionDecisionCategoryWriter(NamedTuple):\n\"\"\"Should be present as top centered element in the first page of a Decision PDF file.\n    Field | Type | Description\n    --:|:--:|:--\n    `element` | [DecisionCategoryChoices][category-choices] | Presently four choices\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the `composition` element is found\n    `writer` | str | The string found indicating the name of the writer\n    `category_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    `writer_pct_height` | float | The writer's coordinates are found below the category coordinates. This can then be used to signify the anchoring start of the document.\n    \"\"\"  # noqa: E501\nelement: DecisionCategoryChoices\ncoordinates: tuple[int, int, int, int]\nwriter: str\ncategory_pct_height: float\nwriter_pct_height: float\n@classmethod\ndef extract(cls, im: np.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in DecisionCategoryChoices:\nif xywh := get_likelihood_centered_coordinates(im, member.value):\n_, y, _, h = xywh\ny0, y1 = y + h, y + 270\nwriter_box = im[y0:y1]\nwriter = pytesseract.image_to_string(writer_box).strip()\nreturn cls(\nelement=member,\ncoordinates=xywh,\nwriter=writer,\ncategory_pct_height=y / im_h,\nwriter_pct_height=y1 / im_h,\n)\nreturn None\n</code></pre>"},{"location":"markers/#notice","title":"Notice","text":"<p>         Bases: <code>NamedTuple</code></p> <p>When present, signifies issuance by authority of the Court.</p> Field Type Description <code>element</code> NoticeChoices Only a single choice (for now) <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the notice is found <code>position_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class PositionNotice(NamedTuple):\n\"\"\"When present, signifies issuance by authority of the Court.\n    Field | Type | Description\n    --:|:--:|:--\n    `element` | NoticeChoices | Only a single choice (for now)\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the notice is found\n    `position_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    \"\"\"  # noqa: E501\nelement: NoticeChoices\ncoordinates: tuple[int, int, int, int]\nposition_pct_height: float\n@classmethod\ndef extract(cls, im: np.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in NoticeChoices:\nif xywh := get_likelihood_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\nposition_pct_height=(y + h) / im_h,\n)\nreturn None\n</code></pre>"},{"location":"positions/","title":"Positions","text":""},{"location":"positions/#positionmeta","title":"PositionMeta","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Metadata required to determine the true start and end pages of a given pdf Path.  Although in a collection of pages there is a logical start and end page, i.e. page 1 and the final page of a document, in Court documents this sometimes does not correspond to the actual start and end of the content.</p> Field Type Description <code>start_index</code> int The zero-based integer <code>x</code>, i.e. get specific <code>pdfplumber.pages[x]</code> <code>start_page_num</code> int The 1-based integer to describe human-readable page number signifying the true content start <code>start_indicator</code> PositionDecisionCategoryWriter or PositionNotice Marking the start of the content proper <code>end_page_num</code> int The 1-based integer to describe human-readable page number signifying the true content end <code>end_page_pos</code> float, int y-axis position in the <code>end_page_num</code> Source code in <code>corpus_unpdf/_positions.py</code> Python<pre><code>class PositionMeta(NamedTuple):\n\"\"\"Metadata required to determine the true start and end pages of a given pdf Path.  Although in a collection of pages\n    there is a logical start and end page, i.e. page 1 and the final page of a document, in Court documents this sometimes\n    does not correspond to the actual start and end of the content.\n    Field | Type | Description\n    --:|:--:|:--\n    `start_index` | int | The zero-based integer `x`, i.e. get specific `pdfplumber.pages[x]`\n    `start_page_num` | int | The 1-based integer to describe human-readable page number signifying the true content start\n    `start_indicator` | [PositionDecisionCategoryWriter][decision-category-writer] or [PositionNotice][notice] | Marking the start of the content proper\n    `end_page_num` | int | The 1-based integer to describe human-readable page number signifying the true content end\n    `end_page_pos` | float, int | _y-axis_ position in the `end_page_num`\n    \"\"\"  # noqa: E501\nstart_index: int\nstart_indicator: PositionDecisionCategoryWriter | PositionNotice\nstart_page_num: int\nend_page_num: int\nend_page_pos: float | int\n@classmethod\ndef prep(cls, path: Path):\nif not (starter := get_start_page_pos(path)):\nraise Exception(\"Could not detect start of content.\")\nindex, start_indicator = starter\nif not start_indicator:\nraise Exception(\"Could not detect start indicator.\")\nender = get_end_page_pos(path)\nif not ender:\nraise Exception(\"Could not detect end of content.\")\nend_page_num, end_page_pos = ender\nreturn cls(\nstart_index=index,\nstart_page_num=index + 1,\nstart_indicator=start_indicator,\nend_page_num=end_page_num,\nend_page_pos=end_page_pos,\n)\n</code></pre>"},{"location":"positions/#terminal-start-page-position","title":"Terminal Start: Page, Position","text":"<p>The actual start of content depends on either the detection of a <code>Notice</code> or a <code>Category</code></p> <p>This requires searching the page from start to finish, via <code>start_ocr.get_pages_and_imgs()</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n&gt;&gt;&gt; res = get_start_page_pos(x)\n&gt;&gt;&gt; type(res[0])\n&lt;class 'int'&gt;\n&gt;&gt;&gt; res[0]\n0\n&gt;&gt;&gt; type(res[1])\n&lt;class 'corpus_unpdf._markers.PositionNotice'&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the PDF file.</p> required <p>Returns:</p> Type Description <code>tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None</code> <p>tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None: The zero-based index of the page (i.e. 0 = page 1), the marker found that signifies start of the content</p> Source code in <code>corpus_unpdf/_positions.py</code> Python<pre><code>def get_start_page_pos(\npath: Path,\n) -&gt; tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None:\n\"\"\"The actual start of content depends on either the detection of a\n    `Notice` or a `Category`\n    This requires searching the page from start to finish, via\n    `start_ocr.get_pages_and_imgs()`\n    Examples:\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n        &gt;&gt;&gt; res = get_start_page_pos(x)\n        &gt;&gt;&gt; type(res[0])\n        &lt;class 'int'&gt;\n        &gt;&gt;&gt; res[0]\n        0\n        &gt;&gt;&gt; type(res[1])\n        &lt;class 'corpus_unpdf._markers.PositionNotice'&gt;\n    Args:\n        path (Path): Path to the PDF file.\n    Returns:\n        tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None:\n            The zero-based index of the page (i.e. 0 = page 1), the marker found that\n            signifies start of the content\n    \"\"\"\nfor page, im in get_pages_and_imgs(path):\nindex = page.page_number - 1  # represents the 0-based index\n_, im_w, _ = im.shape\nMIDPOINT = im_w / 2\nfor cnt in get_contours(im, (30, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\none_liner = h &lt; 100\nx_start_mid = x &lt; MIDPOINT\nx_end_mid = (x + w) &gt; MIDPOINT\nshort_width = 200 &lt; w &lt; 800\nif all([one_liner, x_start_mid, x_end_mid, short_width]):\nsliced = im[y : y + h, x : x + w]\n# cv2.rectangle(im, (x, y), (x + w, y + h), (36, 255, 12), 3)\n# print(f\"{x=}, {y=}, {w=}, {h=}\")\nif is_match_text(sliced, \"notice\"):\nreturn index, PositionNotice.extract(im)\nelif is_match_text(sliced, \"decision\"):\nreturn index, PositionDecisionCategoryWriter.extract(im)\nelif is_match_text(sliced, \"resolution\"):\nreturn index, PositionDecisionCategoryWriter.extract(im)\n# cv2.imwrite(f\"temp/sample_boxes-{page.page_number}.png\", im)\nreturn None\n</code></pre>"},{"location":"positions/#terminal-end-page-number-position","title":"Terminal End: Page Number, Position","text":"<p>The actual end of content depends on either two pieces of text: the <code>Ordered</code> clause or <code>By Authority of the Court</code></p> <p>This requires searching the page in reverse, via <code>get_reverse_pages_and_imgs()</code> since the above pieces of text indicate the end of the content.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n&gt;&gt;&gt; get_end_page_pos(x) # page 5, y-axis 80.88\n(5, 80.88)\n</code></pre> <p>Also see snippets for debugging:</p> Python<pre><code>debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\ncv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\ncv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the PDF file.</p> required <p>Returns:</p> Type Description <code>tuple[int, int] | None</code> <p>tuple[int, int] | None: The page number from pdfplumber.pages, the Y position of that page</p> Source code in <code>corpus_unpdf/_positions.py</code> Python<pre><code>def get_end_page_pos(path: Path) -&gt; tuple[int, int] | None:\n\"\"\"The actual end of content depends on either two pieces of text:\n    the `Ordered` clause or `By Authority of the Court`\n    This requires searching the page in reverse, via\n    `get_reverse_pages_and_imgs()` since the above pieces of text\n    indicate the end of the content.\n    Examples:\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n        &gt;&gt;&gt; get_end_page_pos(x) # page 5, y-axis 80.88\n        (5, 80.88)\n    Also see snippets for debugging:\n    ```py\n    debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\n    cv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\n    cv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n    ```\n    Args:\n        path (Path): Path to the PDF file.\n    Returns:\n        tuple[int, int] | None: The page number from pdfplumber.pages, the Y position\n            of that page\n    \"\"\"\nfor page, im in get_reverse_pages_and_imgs(path):\nim_h, im_w, _ = im.shape\nMIDPOINT = im_w / 2\nfor cnt in get_contours(im, (30, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\nsliced_im = im[y : y + h, x : x + w]\noutput = page.page_number, (y / im_h) * page.height\nif h &lt; 100:\nif x &lt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=ORDERED,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nelif x &gt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=AUTHORITY,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nreturn None\n</code></pre>"}]}