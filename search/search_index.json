{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"corpus-unpdf Docs","text":"<p>Requires <code>start-ocr</code>.</p>"},{"location":"#flow","title":"Flow","text":"<ol> <li>As a document:<ol> <li>Determine start page and start \"y-axis\" position coordinate as start elements, note that is greatly affected by markers</li> <li>Determine end page and start \"y-axis\" position coordinate as end elements</li> </ol> </li> <li>For each page:<ol> <li>Determine \"y-axis\" to slice header</li> <li>Determine \"y-axis\" to slice footer</li> </ol> </li> </ol> <p>Note</p> <p>For slicing to work, each pdf's page, opened and cropped via <code>pdfplumber</code>, must be converted an to an <code>opencv</code> image format (i.e. <code>numpy.ndarray</code>). This enables discovery of contours that can act as borders for slicing content from the page.</p>"},{"location":"decision/","title":"Pages","text":""},{"location":"decision/#get_decision","title":"get_decision","text":"<p>From a *.pdf file found in <code>path</code>, extract relevant metadata to generate a decision having pages. Each of which will contain a body and, likely, an annex for footnotes.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; decision = get_decision(x)\n&gt;&gt;&gt; decision.category\n&lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n&gt;&gt;&gt; decision.composition\n&lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n&gt;&gt;&gt; decision.writer\n'CARPIO. J.:'\n&gt;&gt;&gt; len(decision.pages) # total page count\n5\n&gt;&gt;&gt; isinstance(decision.pages[0], DecisionPage) # first page\nTrue\n&gt;&gt;&gt; from corpus_unpdf.src import Footnote, Bodyline\n&gt;&gt;&gt; isinstance(decision.segments[0], Bodyline)\nTrue\n&gt;&gt;&gt; isinstance(decision.footnotes[0], Footnote)\nTrue\n&gt;&gt;&gt; len(decision.footnotes) # TODO: limited number detected; should be 15\n7\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Decision</code> <p>Instance of a Decision with pages populated</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def get_decision(path: Path) -&gt; Decision:\n\"\"\"From a _*.pdf_ file found in `path`, extract relevant [metadata][decisionmeta]\n    to generate a [decision][decision-document] having [pages][decision-pages].\n    Each of which will contain a body and, likely, an annex for footnotes.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; decision = get_decision(x)\n        &gt;&gt;&gt; decision.category\n        &lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n        &gt;&gt;&gt; decision.composition\n        &lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n        &gt;&gt;&gt; decision.writer\n        'CARPIO. J.:'\n        &gt;&gt;&gt; len(decision.pages) # total page count\n        5\n        &gt;&gt;&gt; isinstance(decision.pages[0], DecisionPage) # first page\n        True\n        &gt;&gt;&gt; from corpus_unpdf.src import Footnote, Bodyline\n        &gt;&gt;&gt; isinstance(decision.segments[0], Bodyline)\n        True\n        &gt;&gt;&gt; isinstance(decision.footnotes[0], Footnote)\n        True\n        &gt;&gt;&gt; len(decision.footnotes) # TODO: limited number detected; should be 15\n        7\n    Args:\n        path (Path): Path to the pdf file.\n    Returns:\n        Self: Instance of a Decision with pages populated\n    \"\"\"  # noqa: E501\nmeta = DecisionMeta.prep(path)\nwith pdfplumber.open(path) as pdf:\n# create all the pages of the decision\ncaso = meta.init(pdf=pdf)\ncontent_pages = meta.add(pages=pdf.pages)\ncaso.pages.extend(content_pages)\n# construct full decision\nobj = construct(caso)\nif isinstance(obj, Decision):\nreturn obj\nraise Exception(\"Bad construction of Decision.\")\n</code></pre>"},{"location":"decision/#decisionmeta","title":"DecisionMeta","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Metadata required to create a decision.</p> Field Type Description <code>start_index</code> int The zero-based integer <code>x</code>, i.e. get specific <code>pdfplumber.pages[x]</code> <code>start_page_num</code> int The 1-based integer to describe human-readable page number <code>start_indicator</code> PositionDecisionCategoryWriter or PositionNotice Marking the start of content proper <code>writer</code> str When PositionDecisionCategoryWriter  is selected, the writer found underneath the category <code>notice</code> bool Will be marked <code>True</code>, if PositionNotice is selected; default is <code>False</code>. <code>pages</code> list[DecisionPage] A list of pages having material content Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>class DecisionMeta(NamedTuple):\n\"\"\"Metadata required to create a [decision][decision-document].\n    Field | Type | Description\n    --:|:--:|:--\n    `start_index` | int | The zero-based integer `x`, i.e. get specific `pdfplumber.pages[x]`\n    `start_page_num` | int | The 1-based integer to describe human-readable page number\n    `start_indicator` | [PositionDecisionCategoryWriter][decision-category-writer] or [PositionNotice][notice] | Marking the [start of content proper][start-of-content]\n    `writer` | str | When [PositionDecisionCategoryWriter][decision-category-writer]  is selected, the writer found underneath the category\n    `notice` | bool | Will be marked `True`, if [PositionNotice][notice] is selected; default is `False`.\n    `pages` | list[[DecisionPage][decision-pages]] | A list of pages having material content\n    \"\"\"  # noqa: E501\nstart_index: int\nstart_page_num: int\nstart_indicator: PositionDecisionCategoryWriter | PositionNotice\nend_page_num: int\nend_page_pos: float | int\n@classmethod\ndef prep(cls, path: Path):\nif not (starter := get_start_page_pos(path)):\nraise Exception(\"Could not detect start of content.\")\nindex, start_indicator = starter\nif not start_indicator:\nraise Exception(\"Could not detect start indicator.\")\nender = get_end_page_pos(path)\nif not ender:\nraise Exception(\"Could not detect end of content.\")\nend_page_num, end_page_pos = ender\nreturn cls(\nstart_index=index,\nstart_page_num=index + 1,\nstart_indicator=start_indicator,\nend_page_num=end_page_num,\nend_page_pos=end_page_pos,\n)\ndef init(self, pdf: PDF) -&gt; Decision:\n\"\"\"Add the metadata of a [Decision][decision-document] and extract the first\n        page of the content proper which may not necessarily be page 1.\n        Returns:\n            Decision: A Decision instance, if all elements match.\n        \"\"\"\nlogger.debug(f\"Initialize {self=}\")\ncomposition = PositionCourtComposition.from_pdf(pdf).element\nstart_page = pdf.pages[self.start_index]\nif isinstance(self.start_indicator, PositionNotice):\nreturn Decision(\ncomposition=composition,\nnotice=True,\npages=[\nDecisionPage.set(\npage=start_page,\nstart_y=self.start_indicator.position_pct_height\n* start_page.height,\n)\n],\n)\nelif isinstance(self.start_indicator, PositionDecisionCategoryWriter):\nreturn Decision(\ncomposition=composition,\ncategory=self.start_indicator.element,\nwriter=self.start_indicator.writer,\npages=[\nDecisionPage.set(\npage=start_page,\nstart_y=self.start_indicator.writer_pct_height\n* start_page.height,\n)\n],\n)\nraise Exception(\"Unexpected initialization of decision.\")\ndef add(self, pages: list[Page]) -&gt; Iterator[DecisionPage]:\nfor nxt in pages:\nif nxt.page_number &lt;= self.start_page_num:\ncontinue\nif nxt.page_number == self.end_page_num:\nlogger.debug(f\"Finalize {nxt.page_number=}.\")\nif page_valid := DecisionPage.set(page=nxt, end_y=self.end_page_pos):\nyield page_valid\nelse:\nlogger.warning(\"Detected blank page.\")\nbreak\nelse:\nlogger.debug(f\"Initialize {nxt.page_number=}.\")\nif page_valid := DecisionPage.set(page=nxt):\nyield page_valid\nelse:\nlogger.warning(\"Detected blank page.\")\n</code></pre>"},{"location":"decision/#corpus_unpdf.DecisionMeta-functions","title":"Functions","text":""},{"location":"decision/#corpus_unpdf.decision.DecisionMeta.init","title":"<code>init(pdf)</code>","text":"<p>Add the metadata of a Decision and extract the first page of the content proper which may not necessarily be page 1.</p> <p>Returns:</p> Name Type Description <code>Decision</code> <code>Decision</code> <p>A Decision instance, if all elements match.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def init(self, pdf: PDF) -&gt; Decision:\n\"\"\"Add the metadata of a [Decision][decision-document] and extract the first\n    page of the content proper which may not necessarily be page 1.\n    Returns:\n        Decision: A Decision instance, if all elements match.\n    \"\"\"\nlogger.debug(f\"Initialize {self=}\")\ncomposition = PositionCourtComposition.from_pdf(pdf).element\nstart_page = pdf.pages[self.start_index]\nif isinstance(self.start_indicator, PositionNotice):\nreturn Decision(\ncomposition=composition,\nnotice=True,\npages=[\nDecisionPage.set(\npage=start_page,\nstart_y=self.start_indicator.position_pct_height\n* start_page.height,\n)\n],\n)\nelif isinstance(self.start_indicator, PositionDecisionCategoryWriter):\nreturn Decision(\ncomposition=composition,\ncategory=self.start_indicator.element,\nwriter=self.start_indicator.writer,\npages=[\nDecisionPage.set(\npage=start_page,\nstart_y=self.start_indicator.writer_pct_height\n* start_page.height,\n)\n],\n)\nraise Exception(\"Unexpected initialization of decision.\")\n</code></pre>"},{"location":"decision/#get_opinion","title":"get_opinion","text":"<p>From a *.pdf file found in <code>path</code>, extract relevant opinion metadata to generate an opinion having pages. Each of which will contain a body and, likely, an annex for footnotes.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"opinion.pdf\"\n&gt;&gt;&gt; opinion = get_opinion(x)\n&gt;&gt;&gt; opinion.writer\n'HERNANDO, J.:'\n&gt;&gt;&gt; opinion.label\n'DISSENTING OPINION'\n&gt;&gt;&gt; len(opinion.pages) # total page count\n28\n&gt;&gt;&gt; isinstance(opinion.pages[0], DecisionPage) # first page\nTrue\n&gt;&gt;&gt; from corpus_unpdf.src import Footnote, Bodyline\n&gt;&gt;&gt; isinstance(opinion.segments[0], Bodyline)\nTrue\n&gt;&gt;&gt; isinstance(opinion.footnotes[0], Footnote)\nTrue\n&gt;&gt;&gt; len(opinion.footnotes)\n47\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Opinion</code> <p>Instance of an Opinion with pages populated</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def get_opinion(path: Path) -&gt; Opinion:\n\"\"\"From a _*.pdf_ file found in `path`, extract relevant opinion metadata\n    to generate an [opinion][opinion-document] having [pages][decision-pages].\n    Each of which will contain a body and, likely, an annex for footnotes.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"opinion.pdf\"\n        &gt;&gt;&gt; opinion = get_opinion(x)\n        &gt;&gt;&gt; opinion.writer\n        'HERNANDO, J.:'\n        &gt;&gt;&gt; opinion.label\n        'DISSENTING OPINION'\n        &gt;&gt;&gt; len(opinion.pages) # total page count\n        28\n        &gt;&gt;&gt; isinstance(opinion.pages[0], DecisionPage) # first page\n        True\n        &gt;&gt;&gt; from corpus_unpdf.src import Footnote, Bodyline\n        &gt;&gt;&gt; isinstance(opinion.segments[0], Bodyline)\n        True\n        &gt;&gt;&gt; isinstance(opinion.footnotes[0], Footnote)\n        True\n        &gt;&gt;&gt; len(opinion.footnotes)\n        47\n    Args:\n        path (Path): Path to the pdf file.\n    Returns:\n        Self: Instance of an Opinion with pages populated\n    \"\"\"  # noqa: E501\nwith pdfplumber.open(path) as pdf:\nmeta = PositionOpinion.from_pdf(pdf)\n# initialize the opinion\nstart_page = pdf.pages[0]\nstart_y = meta.writer_pct_height * start_page.height\nopinion = Opinion(\nlabel=meta.label,\nwriter=meta.writer,\npages=[DecisionPage.set(page=start_page, start_y=start_y)],\n)\n# create all the pages of the opinion\nfor page in pdf.pages[1:]:\nif page_valid := DecisionPage.set(page=page):\nopinion.pages.append(page_valid)\n# construct full opinion\nobj = construct(opinion)\nif isinstance(obj, Opinion):\nreturn obj\nraise Exception(\"Bad construction of Opinion.\")\n</code></pre>"},{"location":"document/","title":"Document","text":""},{"location":"document/#decision-document","title":"Decision Document","text":"<p>Metadata of a pdf file parsed via <code>get_decision()</code></p> Field Description <code>composition</code> The composition of the Supreme Court that decided the case <code>category</code> When available, whether the case is a \"Decision\" or a \"Resolution\" <code>header</code> The top portion of the page, usually excluded from metadata <code>writer</code> When available, the writer of the case <code>notice</code> When True, means that there is no <code>category</code> available <code>pages</code> A list of Decision Pages <code>body</code> The compiled string consisting of each page's <code>body_text</code> <code>annex</code> The compiled string consisting of each page's <code>annex_text</code>, if existing <code>segments</code> Each bodyline of the body's text <code>footnotes</code> Each footnote in the annex's text Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>@dataclass\nclass Decision:\n\"\"\"Metadata of a pdf file parsed via `get_decision()`\n    Field | Description\n    --:|:--\n    `composition` | The composition of the Supreme Court that decided the case\n    `category` | When available, whether the case is a \"Decision\" or a \"Resolution\"\n    `header` | The top portion of the page, usually excluded from metadata\n    `writer` | When available, the writer of the case\n    `notice` | When True, means that there is no `category` available\n    `pages` | A list of [Decision Pages][decision-pages]\n    `body` | The compiled string consisting of each page's `body_text`\n    `annex` | The compiled string consisting of each page's `annex_text`, if existing\n    `segments` | Each [bodyline][bodyline] of the body's text\n    `footnotes` | Each [footnote][footnote] in the annex's text\n    \"\"\"\ncomposition: CourtCompositionChoices\ncategory: DecisionCategoryChoices | None = None\nheader: CroppedPage | None = None\nwriter: str | None = None\nnotice: bool = False\npages: list[DecisionPage] = field(default_factory=list)\nsegments: list[Bodyline] = field(default_factory=list)\nfootnotes: list[Footnote] = field(default_factory=list)\nbody: str = \"\"\nannex: str = \"\"\ndef __repr__(self) -&gt; str:\nreturn f\"Decision {self.composition.value}, pages {len(self.pages)}\"\n</code></pre>"},{"location":"document/#opinion-document","title":"Opinion Document","text":"<p>Metadata of a pdf file parsed via <code>get_opinion()</code></p> Field Description <code>label</code> How the opinion is labelled <code>writer</code> When available, the writer of the case <code>pages</code> A list of Decision Pages <code>body</code> The compiled string consisting of each page's <code>body_text</code> <code>annex</code> The compiled string consisting of each page's <code>annex_text</code>, if existing <code>segments</code> Each bodyline of the body's text <code>footnotes</code> Each footnote in the annex's text Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>@dataclass\nclass Opinion:\n\"\"\"Metadata of a pdf file parsed via `get_opinion()`\n    Field | Description\n    --:|:--\n    `label` | How the opinion is labelled\n    `writer` | When available, the writer of the case\n    `pages` | A list of [Decision Pages][decision-pages]\n    `body` | The compiled string consisting of each page's `body_text`\n    `annex` | The compiled string consisting of each page's `annex_text`, if existing\n    `segments` | Each [bodyline][bodyline] of the body's text\n    `footnotes` | Each [footnote][footnote] in the annex's text\n    \"\"\"\nlabel: str\nwriter: str\npages: list[DecisionPage] = field(default_factory=list)\nsegments: list[Bodyline] = field(default_factory=list)\nfootnotes: list[Footnote] = field(default_factory=list)\nbody: str = \"\"\nannex: str = \"\"\ndef __repr__(self) -&gt; str:\nreturn f\"{self.writer.title()} | {self.label.title()}: pages {len(self.pages)}\"\n</code></pre>"},{"location":"document/#decision-pages","title":"Decision Pages","text":"<p>Metadata of a single decision page.</p> Field Description <code>page_num</code> The page number of the Decision page <code>body</code> The main content above the annex, if existing <code>segments</code> Segments of the <code>body</code>'s text in the given <code>page_num</code>, see Bodyline <code>annex</code> Portion of page containing the footnotes; some pages are annex-free <code>footnotes</code> Each footnote item in the <code>annex</code>'s text in the given <code>page_num</code>, see Footnote Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>@dataclass\nclass DecisionPage:\n\"\"\"Metadata of a single decision page.\n    Field | Description\n    --:|:--\n    `page_num` | The page number of the Decision page\n    `body` | The main content above the annex, if existing\n    `segments` | Segments of the `body`'s text in the given `page_num`, see [Bodyline][bodyline]\n    `annex` | Portion of page containing the footnotes; some pages are annex-free\n    `footnotes` | Each footnote item in the `annex`'s text in the given `page_num`, see [Footnote][footnote]\n    \"\"\"  # noqa: E501\npage_num: int\nbody: CroppedPage\nbody_text: str\nannex: CroppedPage | None = None\nannex_text: str | None = None\nsegments: list[Bodyline] = field(default_factory=list)\nfootnotes: list[Footnote] = field(default_factory=list)\ndef __post_init__(self):\nalpha = paragraph_break.split(self.body_text)\nbeta = self.body_text.split(\"\\n\\n\")\ncandidates = alpha or beta\nself.segments = Bodyline.split(candidates, self.page_num)\nif self.annex and self.annex_text:\nself.footnotes = Footnote.extract_notes(self.annex_text, self.page_num)\n@classmethod\ndef set(\ncls,\npage: Page,\nstart_y: float | int | None = None,\nend_y: float | int | None = None,\n) -&gt; Self:\n\"\"\"\n        A `header_line` (related to `start_y`) and `page_line` (related to `end_y`)\n        are utilized as local variables in this function.\n        The `header_line` is the imaginary line at the top of the page.\n        If the `start_y` is supplied, it means that the `header_line`\n        no longer needs to be calculated.\n        The `page_line` is the imaginary line at the bottom of the page.\n        If the `end_y` is supplied, it means that the calculated `page_line`\n        ought to be replaced.\n        The presence of a `header_line` and a `page_endline` determine\n        what to extract from a given `page`.\n        Args:\n            page (Page): The pdfplumber page to evaluate\n            start_y (float | int | None, optional): If present, refers to\n                The y-axis point of the starter page. Defaults to None.\n            end_y (float | int | None, optional): If present, refers to\n                The y-axis point of the ender page. Defaults to None.\n        Returns:\n            Self: Page with individual components mapped out.\n        \"\"\"\nim = get_img_from_page(page)\nheader_line = start_y or get_header_line(im, page)\nif not header_line:\nraise Exception(f\"No header line in {page.page_number=}\")\nend_of_content, e = get_page_end(im, page)\npage_line = end_y or end_of_content\nbody = PageCut.set(page=page, y0=header_line, y1=page_line)\nbody_text = cls.get_content(body)\nannex = None\nannex_text = None\nif e:\nannex = PageCut.set(page=page, y0=end_of_content, y1=e)\nannex_text = cls.get_content(annex)\nreturn cls(\npage_num=get_page_num(page, header_line),\nbody=body,\nbody_text=body_text,\nannex=annex,\nannex_text=annex_text,\n)\n@classmethod\ndef get_content(cls, crop: CroppedPage):\nreturn cls.text_from_plumber(crop) or cls.text_from_image(crop)\n@classmethod\ndef text_from_plumber(cls, crop: CroppedPage) -&gt; str:\n\"\"\"pdfplumber features an experimental setting of capturing the\n        image's blank spaces and layout. This would be useful in determining\n        line breaks.\n        Args:\n            crop (CroppedPage): pdfplumber CroppedPage.\n        Returns:\n            str: text found from the cropped page.\n        \"\"\"\nreturn crop.extract_text(layout=True, keep_blank_chars=True).strip()\n@classmethod\ndef text_from_image(cls, crop: CroppedPage) -&gt; str:\n\"\"\"In the event that pdfplumber's `extract_text()` fails, i.e. no\n        text is produced, use the pytesseract method. First convert the\n        image to its `PIL` format then from convert it to openCV\n        so that it can be used by pytesseract.\"\"\"\nreturn pytesseract.image_to_string(\ncv2.cvtColor(\nnumpy.array(crop.to_image(resolution=300).original),\ncv2.COLOR_RGB2BGR,\n)\n).strip()\n</code></pre>"},{"location":"document/#corpus_unpdf.src.decision_objects.DecisionPage-functions","title":"Functions","text":""},{"location":"document/#corpus_unpdf.src.decision_objects.DecisionPage.set","title":"<code>set(page, start_y=None, end_y=None)</code>  <code>classmethod</code>","text":"<p>A <code>header_line</code> (related to <code>start_y</code>) and <code>page_line</code> (related to <code>end_y</code>) are utilized as local variables in this function.</p> <p>The <code>header_line</code> is the imaginary line at the top of the page. If the <code>start_y</code> is supplied, it means that the <code>header_line</code> no longer needs to be calculated.</p> <p>The <code>page_line</code> is the imaginary line at the bottom of the page. If the <code>end_y</code> is supplied, it means that the calculated <code>page_line</code> ought to be replaced.</p> <p>The presence of a <code>header_line</code> and a <code>page_endline</code> determine what to extract from a given <code>page</code>.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>The pdfplumber page to evaluate</p> required <code>start_y</code> <code>float | int | None</code> <p>If present, refers to The y-axis point of the starter page. Defaults to None.</p> <code>None</code> <code>end_y</code> <code>float | int | None</code> <p>If present, refers to The y-axis point of the ender page. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Page with individual components mapped out.</p> Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>@classmethod\ndef set(\ncls,\npage: Page,\nstart_y: float | int | None = None,\nend_y: float | int | None = None,\n) -&gt; Self:\n\"\"\"\n    A `header_line` (related to `start_y`) and `page_line` (related to `end_y`)\n    are utilized as local variables in this function.\n    The `header_line` is the imaginary line at the top of the page.\n    If the `start_y` is supplied, it means that the `header_line`\n    no longer needs to be calculated.\n    The `page_line` is the imaginary line at the bottom of the page.\n    If the `end_y` is supplied, it means that the calculated `page_line`\n    ought to be replaced.\n    The presence of a `header_line` and a `page_endline` determine\n    what to extract from a given `page`.\n    Args:\n        page (Page): The pdfplumber page to evaluate\n        start_y (float | int | None, optional): If present, refers to\n            The y-axis point of the starter page. Defaults to None.\n        end_y (float | int | None, optional): If present, refers to\n            The y-axis point of the ender page. Defaults to None.\n    Returns:\n        Self: Page with individual components mapped out.\n    \"\"\"\nim = get_img_from_page(page)\nheader_line = start_y or get_header_line(im, page)\nif not header_line:\nraise Exception(f\"No header line in {page.page_number=}\")\nend_of_content, e = get_page_end(im, page)\npage_line = end_y or end_of_content\nbody = PageCut.set(page=page, y0=header_line, y1=page_line)\nbody_text = cls.get_content(body)\nannex = None\nannex_text = None\nif e:\nannex = PageCut.set(page=page, y0=end_of_content, y1=e)\nannex_text = cls.get_content(annex)\nreturn cls(\npage_num=get_page_num(page, header_line),\nbody=body,\nbody_text=body_text,\nannex=annex,\nannex_text=annex_text,\n)\n</code></pre>"},{"location":"document/#corpus_unpdf.src.decision_objects.DecisionPage.text_from_image","title":"<code>text_from_image(crop)</code>  <code>classmethod</code>","text":"<p>In the event that pdfplumber's <code>extract_text()</code> fails, i.e. no text is produced, use the pytesseract method. First convert the image to its <code>PIL</code> format then from convert it to openCV so that it can be used by pytesseract.</p> Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>@classmethod\ndef text_from_image(cls, crop: CroppedPage) -&gt; str:\n\"\"\"In the event that pdfplumber's `extract_text()` fails, i.e. no\n    text is produced, use the pytesseract method. First convert the\n    image to its `PIL` format then from convert it to openCV\n    so that it can be used by pytesseract.\"\"\"\nreturn pytesseract.image_to_string(\ncv2.cvtColor(\nnumpy.array(crop.to_image(resolution=300).original),\ncv2.COLOR_RGB2BGR,\n)\n).strip()\n</code></pre>"},{"location":"document/#corpus_unpdf.src.decision_objects.DecisionPage.text_from_plumber","title":"<code>text_from_plumber(crop)</code>  <code>classmethod</code>","text":"<p>pdfplumber features an experimental setting of capturing the image's blank spaces and layout. This would be useful in determining line breaks.</p> <p>Parameters:</p> Name Type Description Default <code>crop</code> <code>CroppedPage</code> <p>pdfplumber CroppedPage.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>text found from the cropped page.</p> Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>@classmethod\ndef text_from_plumber(cls, crop: CroppedPage) -&gt; str:\n\"\"\"pdfplumber features an experimental setting of capturing the\n    image's blank spaces and layout. This would be useful in determining\n    line breaks.\n    Args:\n        crop (CroppedPage): pdfplumber CroppedPage.\n    Returns:\n        str: text found from the cropped page.\n    \"\"\"\nreturn crop.extract_text(layout=True, keep_blank_chars=True).strip()\n</code></pre>"},{"location":"document/#parts-of-page","title":"Parts of Page","text":""},{"location":"document/#bodyline","title":"Bodyline","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Each page may be divided into lines which, for our purposes, will refer to an arbitrary segmentation of text based on regex parameters.</p> Field Type Description <code>num</code> int Order in the page <code>line</code> str The text found based on segmentation Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>class Bodyline(NamedTuple):\n\"\"\"Each page may be divided into lines which, for our purposes,\n    will refer to an arbitrary segmentation of text based on regex parameters.\n    Field | Type | Description\n    --:|:--:|:--\n    `num` | int | Order in the page\n    `line` | str | The text found based on segmentation\n    \"\"\"\npage_num: int\norder_num: int\nline: str\n@classmethod\ndef split(cls, prelim_lines: list[str], page_num: int) -&gt; list[Self]:\n\"\"\"Get paragraphs using regex `\\\\s{10,}(?=[A-Z])`\n        implying many spaces before a capital letter then\n        remove new lines contained in non-paragraph lines.\n        Args:\n            prelim_lines (list[str]): Previously split text\n        Returns:\n            list[Self]: Bodylines of segmented text\n        \"\"\"\nlines = []\nfor order_num, par in enumerate(prelim_lines, start=1):\nobj = cls(\npage_num=page_num,\norder_num=order_num,\nline=line_break.sub(\" \", par).strip(),\n)\nlines.append(obj)\nlines.sort(key=lambda obj: obj.order_num)\nreturn lines\n</code></pre>"},{"location":"document/#corpus_unpdf.src.decision_objects.Bodyline-functions","title":"Functions","text":""},{"location":"document/#corpus_unpdf.src.decision_objects.Bodyline.split","title":"<code>split(prelim_lines, page_num)</code>  <code>classmethod</code>","text":"<p>Get paragraphs using regex <code>\\s{10,}(?=[A-Z])</code> implying many spaces before a capital letter then remove new lines contained in non-paragraph lines.</p> <p>Parameters:</p> Name Type Description Default <code>prelim_lines</code> <code>list[str]</code> <p>Previously split text</p> required <p>Returns:</p> Type Description <code>list[Self]</code> <p>list[Self]: Bodylines of segmented text</p> Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>@classmethod\ndef split(cls, prelim_lines: list[str], page_num: int) -&gt; list[Self]:\n\"\"\"Get paragraphs using regex `\\\\s{10,}(?=[A-Z])`\n    implying many spaces before a capital letter then\n    remove new lines contained in non-paragraph lines.\n    Args:\n        prelim_lines (list[str]): Previously split text\n    Returns:\n        list[Self]: Bodylines of segmented text\n    \"\"\"\nlines = []\nfor order_num, par in enumerate(prelim_lines, start=1):\nobj = cls(\npage_num=page_num,\norder_num=order_num,\nline=line_break.sub(\" \", par).strip(),\n)\nlines.append(obj)\nlines.sort(key=lambda obj: obj.order_num)\nreturn lines\n</code></pre>"},{"location":"document/#footnote","title":"Footnote","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Each page may contain an annex which consists of footnotes. Note that this is based on a imperfect use of regex to detect the footnote number <code>fn_id</code> and its corresponding text <code>note</code>.</p> Field Type Description <code>fn_id</code> int Footnote number <code>note</code> str The text found based on segmentation of footnotes Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>class Footnote(NamedTuple):\n\"\"\"Each page may contain an annex which consists of footnotes. Note\n    that this is based on a imperfect use of regex to detect the footnote\n    number `fn_id` and its corresponding text `note`.\n    Field | Type | Description\n    --:|:--:|:--\n    `fn_id` | int | Footnote number\n    `note` | str | The text found based on segmentation of footnotes\n    \"\"\"\npage_num: int\nfn_id: int\nnote: str\n@classmethod\ndef extract_notes(cls, text: str, page_num: int) -&gt; list[Self]:\n\"\"\"Get footnote digits using regex `\\\\n\\\\s+(?P&lt;fn&gt;\\\\d+)(?=\\\\s+[A-Z])`\n        then for each matching span, the start span becomes the anchor\n        for the balance of the text for each remaining foornote in the while\n        loop. The while loop extraction must use `.pop()` where the last\n        item is removed first.\n        Args:\n            text (str): Text that should be convertible to footnotes based on regex\n        Returns:\n            list[Self]: Footnotes separated by digits.\n        \"\"\"\nnotes = []\nwhile True:\nmatches = list(footnote_nums.finditer(text))\nif not matches:\nbreak\nnote = matches.pop()  # start from the last\nfootnote_num = int(note.group(\"fn\"))\ndigit_start, digit_end = note.span()\nfootnote_body = text[digit_end:].strip()\nobj = cls(\npage_num=page_num,\nfn_id=footnote_num,\nnote=footnote_body,\n)\nnotes.append(obj)\ntext = text[:digit_start]\nnotes.sort(key=lambda obj: obj.fn_id)\nreturn notes\n</code></pre>"},{"location":"document/#corpus_unpdf.src.decision_objects.Footnote-functions","title":"Functions","text":""},{"location":"document/#corpus_unpdf.src.decision_objects.Footnote.extract_notes","title":"<code>extract_notes(text, page_num)</code>  <code>classmethod</code>","text":"<p>Get footnote digits using regex <code>\\n\\s+(?P&lt;fn&gt;\\d+)(?=\\s+[A-Z])</code> then for each matching span, the start span becomes the anchor for the balance of the text for each remaining foornote in the while loop. The while loop extraction must use <code>.pop()</code> where the last item is removed first.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text that should be convertible to footnotes based on regex</p> required <p>Returns:</p> Type Description <code>list[Self]</code> <p>list[Self]: Footnotes separated by digits.</p> Source code in <code>corpus_unpdf/src/decision_objects.py</code> Python<pre><code>@classmethod\ndef extract_notes(cls, text: str, page_num: int) -&gt; list[Self]:\n\"\"\"Get footnote digits using regex `\\\\n\\\\s+(?P&lt;fn&gt;\\\\d+)(?=\\\\s+[A-Z])`\n    then for each matching span, the start span becomes the anchor\n    for the balance of the text for each remaining foornote in the while\n    loop. The while loop extraction must use `.pop()` where the last\n    item is removed first.\n    Args:\n        text (str): Text that should be convertible to footnotes based on regex\n    Returns:\n        list[Self]: Footnotes separated by digits.\n    \"\"\"\nnotes = []\nwhile True:\nmatches = list(footnote_nums.finditer(text))\nif not matches:\nbreak\nnote = matches.pop()  # start from the last\nfootnote_num = int(note.group(\"fn\"))\ndigit_start, digit_end = note.span()\nfootnote_body = text[digit_end:].strip()\nobj = cls(\npage_num=page_num,\nfn_id=footnote_num,\nnote=footnote_body,\n)\nnotes.append(obj)\ntext = text[:digit_start]\nnotes.sort(key=lambda obj: obj.fn_id)\nreturn notes\n</code></pre>"},{"location":"document-parts/ender/","title":"End of Content","text":""},{"location":"document-parts/ender/#terminal-end-page-number-position","title":"Terminal End: Page Number, Position","text":"<p>Although the collection of pages has a logical end page, this oftentimes does not correspond to the actual end of the content.</p> <p>The actual end of content depends on either two pieces of text: the <code>Ordered</code> clause or <code>By Authority of the Court</code></p> <p>This requires searching the page in reverse, via <code>get_reverse_pages_and_imgs()</code> since the above pieces of text indicate the end of the content.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n&gt;&gt;&gt; get_end_page_pos(x) # page 5, y-axis 80.88\n(5, 80.88)\n</code></pre> <p>Also see snippets for debugging:</p> Python<pre><code>debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\ncv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\ncv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the PDF file.</p> required <p>Returns:</p> Type Description <code>tuple[int, int] | None</code> <p>tuple[int, int] | None: The page number from pdfplumber.pages, the Y position of that page</p> Source code in <code>corpus_unpdf/src/content_ender.py</code> Python<pre><code>def get_end_page_pos(path: Path) -&gt; tuple[int, int] | None:\n\"\"\"Although the collection of pages has a logical end page, this\n    oftentimes does not correspond to the actual end of the content.\n    The actual end of content depends on either two pieces of text:\n    the `Ordered` clause or `By Authority of the Court`\n    This requires searching the page in reverse, via\n    `get_reverse_pages_and_imgs()` since the above pieces of text\n    indicate the end of the content.\n    Examples:\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n        &gt;&gt;&gt; get_end_page_pos(x) # page 5, y-axis 80.88\n        (5, 80.88)\n    Also see snippets for debugging:\n    ```py\n    debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\n    cv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\n    cv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n    ```\n    Args:\n        path (Path): Path to the PDF file.\n    Returns:\n        tuple[int, int] | None: The page number from pdfplumber.pages, the Y position\n            of that page\n    \"\"\"\nORDERED, AUTHORITY = \"so ordered\", \"by authority of the court\"\nfor page, im in get_reverse_pages_and_imgs(path):\nim_h, im_w, _ = im.shape\nMIDPOINT = im_w / 2\nfor cnt in get_contours(im, (30, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\nsliced_im = im[y : y + h, x : x + w]\noutput = page.page_number, (y / im_h) * page.height\nif h &lt; 100:\nif x &lt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=ORDERED,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nelif x &gt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=AUTHORITY,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nreturn None\n</code></pre>"},{"location":"document-parts/markers/","title":"Markers","text":"<p>Typically used in the title page of a Decision document to determine the positions of Y-coordinates and to extract the metadata associated with the page.</p> <p>Warning</p> <p>Not all markers are found in the preliminary page. Hence, the need to find   the anchoring start of content.</p>"},{"location":"document-parts/markers/#court-composition","title":"Court Composition","text":""},{"location":"document-parts/markers/#composition-choices","title":"Composition Choices","text":"<p>         Bases: <code>Enum</code></p> <p>How the Supreme Court sits. At present, this includes four options: en banc + 3 divisions. Might need to add cases for special divisions.</p> Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class CourtCompositionChoices(Enum):\n\"\"\"How the Supreme Court sits. At present, this includes four\n    options: en banc + 3 divisions. Might need to add cases for _special_ divisions.\n    \"\"\"\nENBANC = \"En Banc\"\nDIV1 = \"First Division\"\nDIV2 = \"Second Division\"\nDIV3 = \"Third Division\"\n</code></pre>"},{"location":"document-parts/markers/#extract-composition","title":"Extract Composition","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Should be present as the top centered element in the first page of the pdf of the Decision.</p> Field Type Description <code>element</code> CourtCompositionChoices Presently four choices <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the composition is found <code>composition_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class PositionCourtComposition(NamedTuple):\n\"\"\"Should be present as the top centered element in the first page\n    of the pdf of the Decision.\n    Field | Type | Description\n    --:|:--:|:--\n    `element` | [CourtCompositionChoices][composition-choices] | Presently four choices\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the composition is found\n    `composition_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    \"\"\"  # noqa: E501\nelement: CourtCompositionChoices\ncoordinates: tuple[int, int, int, int]\ncomposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in CourtCompositionChoices:\nif xywh := get_likelihood_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\ncomposition_pct_height=(y + h) / im_h,\n)\nreturn None\n@classmethod\ndef from_pdf(cls, pdf: PDF) -&gt; Self:\npage_one_im = get_img_from_page(pdf.pages[0])\ncourt_composition = cls.extract(page_one_im)\nif not court_composition:\nraise Exception(\"Could not detect court compositon in page 1.\")\nreturn court_composition\n</code></pre>"},{"location":"document-parts/markers/#decision-category-writer","title":"Decision Category &amp; Writer","text":""},{"location":"document-parts/markers/#category-choices","title":"Category Choices","text":"<p>         Bases: <code>Enum</code></p> <p>The classification of a decision issued by the Supreme Court, i.e. a decision or a resolution.</p> Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class DecisionCategoryChoices(Enum):\n\"\"\"The classification of a decision issued by the Supreme Court, i.e.\n    a decision or a resolution.\"\"\"\nCASO = \"Decision\"\nRESO = \"Resolution\"\n</code></pre>"},{"location":"document-parts/markers/#extract-category","title":"Extract Category","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Should be present as the top centered element in the first page of the pdf of the Decision.</p> Field Type Description <code>element</code> DecisionCategoryChoices Presently four choices <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the <code>composition</code> element is found <code>writer</code> str The string found indicating the name of the writer <code>category_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. <code>writer_pct_height</code> float The writer's coordinates are found below the category coordinates. This can then be used to signify the anchoring start of the document. Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class PositionDecisionCategoryWriter(NamedTuple):\n\"\"\"Should be present as the top centered element in the first page\n    of the pdf of the Decision.\n    Field | Type | Description\n    --:|:--:|:--\n    `element` | [DecisionCategoryChoices][category-choices] | Presently four choices\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the `composition` element is found\n    `writer` | str | The string found indicating the name of the writer\n    `category_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    `writer_pct_height` | float | The writer's coordinates are found below the category coordinates. This can then be used to signify the anchoring [start of the document][start-of-content].\n    \"\"\"  # noqa: E501\nelement: DecisionCategoryChoices\ncoordinates: tuple[int, int, int, int]\nwriter: str\ncategory_pct_height: float\nwriter_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in DecisionCategoryChoices:\nif xywh := get_likelihood_centered_coordinates(im, member.value):\n_, y, _, h = xywh\ny0, y1 = y + h, y + 270\nwriter_box = im[y0:y1]\nwriter = pytesseract.image_to_string(writer_box).strip()\nreturn cls(\nelement=member,\ncoordinates=xywh,\nwriter=writer,\ncategory_pct_height=y / im_h,\nwriter_pct_height=y1 / im_h,\n)\nreturn None\n</code></pre>"},{"location":"document-parts/markers/#notice","title":"Notice","text":"<p>         Bases: <code>NamedTuple</code></p> <p>When present, signifies that this was issued by authority of the Court.</p> Field Type Description <code>element</code> NoticeChoices Only a single choice (for now) <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the notice is found <code>position_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class PositionNotice(NamedTuple):\n\"\"\"When present, signifies that this was issued by authority of the Court.\n    Field | Type | Description\n    --:|:--:|:--\n    `element` | NoticeChoices | Only a single choice (for now)\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the notice is found\n    `position_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    \"\"\"  # noqa: E501\nelement: NoticeChoices\ncoordinates: tuple[int, int, int, int]\nposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in NoticeChoices:\nif xywh := get_likelihood_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\nposition_pct_height=(y + h) / im_h,\n)\nreturn None\n</code></pre>"},{"location":"document-parts/markers/#opinion","title":"Opinion","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Should be present as the top centered element in the first page of the pdf of the Opinion.</p> Field Type Description <code>label</code> str Should be a phase including the word 'Opinion' <code>writer</code> str The string found indicating the name of the writer <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the <code>label</code> is found <code>opinion_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. <code>writer_pct_height</code> float The writer's coordinates are found below the label <code>coordinates</code>. This can then be used to signify the anchoring start of the document. Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class PositionOpinion(NamedTuple):\n\"\"\"Should be present as the top centered element in the first page\n    of the pdf of the Opinion.\n    Field | Type | Description\n    --:|:--:|:--\n    `label` | str | Should be a phase including the word 'Opinion'\n    `writer` | str | The string found indicating the name of the writer\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the `label` is found\n    `opinion_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    `writer_pct_height` | float | The writer's coordinates are found below the label `coordinates`. This can then be used to signify the anchoring [start of the document][start-of-content].\n    \"\"\"  # noqa: E501\nlabel: str\nwriter: str\ncoordinates: tuple[int, int, int, int]\nopinion_pct_height: float\nwriter_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, im_w, _ = im.shape\nfor cnt in get_contours(im, (50, 50)):\nx, y, w, h = cv2.boundingRect(cnt)\nx0_mid_left = (1 * im_w) / 4 &lt; x\nendpoint_on_right = x + w &gt; im_w / 2\nshort_width = w &gt; 200\nif all([x0_mid_left, endpoint_on_right, short_width]):\nsliced_im = im[y : y + h, x : x + w]\nlabel = pytesseract.image_to_string(sliced_im).strip().upper()\ny0, y1 = y + h, y + 270\nwriter_box = im[y0:y1]\nwriter = pytesseract.image_to_string(writer_box).strip()\nif \"OPINION\" in label:\nreturn cls(\nlabel=label,\ncoordinates=(x, y, w, h),\nwriter=writer,\nopinion_pct_height=(y + h) / im_h,\nwriter_pct_height=y1 / im_h,\n)\nreturn None\n@classmethod\ndef from_pdf(cls, pdf: PDF) -&gt; Self:\npage_one_im = get_img_from_page(pdf.pages[0])\nopinion_label = cls.extract(page_one_im)\nif not opinion_label:\nraise Exception(\"Could not detect opinion in page 1.\")\nreturn opinion_label\n</code></pre>"},{"location":"document-parts/starter/","title":"Start of Content","text":""},{"location":"document-parts/starter/#terminal-start-page-position","title":"Terminal Start: Page, Position","text":"<p>Although the collection of pages has a logical start page, this exceptionally does not correspond to the actual start of the content.</p> <p>The actual start of content depends on either the detection of a Notice or a Category</p> <p>This requires searching the page from start to finish, via <code>get_pages_and_imgs()</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n&gt;&gt;&gt; res = get_start_page_pos(x)\n&gt;&gt;&gt; type(res[0])\n&lt;class 'int'&gt;\n&gt;&gt;&gt; res[0]\n0\n&gt;&gt;&gt; type(res[1])\n&lt;class 'corpus_unpdf.src.content_markers.PositionNotice'&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the PDF file.</p> required <p>Returns:</p> Type Description <code>tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None</code> <p>tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None: The zero-based index of the page (i.e. 0 = page 1), the marker found that signifies start of the content</p> Source code in <code>corpus_unpdf/src/content_starter.py</code> Python<pre><code>def get_start_page_pos(\npath: Path,\n) -&gt; tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None:\n\"\"\"Although the collection of pages has a logical start page, this\n    _exceptionally_ does not correspond to the actual start of the content.\n    The actual start of content depends on either the detection of a\n    Notice or a Category\n    This requires searching the page from start to finish, via\n    `get_pages_and_imgs()`\n    Examples:\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n        &gt;&gt;&gt; res = get_start_page_pos(x)\n        &gt;&gt;&gt; type(res[0])\n        &lt;class 'int'&gt;\n        &gt;&gt;&gt; res[0]\n        0\n        &gt;&gt;&gt; type(res[1])\n        &lt;class 'corpus_unpdf.src.content_markers.PositionNotice'&gt;\n    Args:\n        path (Path): Path to the PDF file.\n    Returns:\n        tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None:\n            The zero-based index of the page (i.e. 0 = page 1), the marker found that\n            signifies start of the content\n    \"\"\"\nfor page, im in get_pages_and_imgs(path):\nindex = page.page_number - 1  # represents the 0-based index\n_, im_w, _ = im.shape\nMIDPOINT = im_w / 2\nfor cnt in get_contours(im, (30, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\none_liner = h &lt; 100\nx_start_mid = x &lt; MIDPOINT\nx_end_mid = (x + w) &gt; MIDPOINT\nshort_width = 200 &lt; w &lt; 800\nif all([one_liner, x_start_mid, x_end_mid, short_width]):\nsliced = im[y : y + h, x : x + w]\n# cv2.rectangle(im, (x, y), (x + w, y + h), (36, 255, 12), 3)\n# print(f\"{x=}, {y=}, {w=}, {h=}\")\nif is_match_text(sliced, \"notice\"):\nreturn index, PositionNotice.extract(im)\nelif is_match_text(sliced, \"decision\"):\nreturn index, PositionDecisionCategoryWriter.extract(im)\nelif is_match_text(sliced, \"resolution\"):\nreturn index, PositionDecisionCategoryWriter.extract(im)\n# cv2.imwrite(f\"temp/sample_boxes-{page.page_number}.png\", im)\nreturn None\n</code></pre>"}]}