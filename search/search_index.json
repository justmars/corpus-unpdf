{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"corpus-unpdf Docs","text":"<p>PDF, as a file format, is the bane of programmatic text analysis.</p> <p>It's not a document format like <code>.txt</code>, <code>.docx</code>, <code>.md</code>, etc. where elements of a document such as (a) layout, (b) words, (c) lines, etc. can be extracted easily.</p> <p>Instead, PDFs can be equated to instructions producing human-comprehensible, yet machine-confusing outputs.</p> <p>Humans can eyeball these outputs and understand the result. Machines however can only parse and make a guess as to its contents. Put another way:</p> <p>Note</p> <p>PDF = humans good, machines bad</p> <p>In light of this context, this library is an attempt to parse Philippine Supreme Court decisions issued in PDF format and extract its raw \"as guessed\" output.</p>"},{"location":"#measurements","title":"Measurements","text":"<p>Since we'll be using two distinct libraries with different formats, pay attention to the kind of measurements involved.</p>"},{"location":"#unit","title":"Unit","text":"Library Unit Description Maximum pdfplumber point PDF unit <code>im.shape</code> gets a tuple of the image dimensions opencv pixel Graphical unit <code>page.height * page.width</code> is the size of the page <p>Warning</p> <p>Convert image's pixels as page points, by first getting image ratio; then apply ratio (percentage) to the page's max width / height.</p> Python<pre><code>&gt;&gt;&gt; from corpus_unpdf.src.common import get_contours # shortcut custom function\n&gt;&gt;&gt; im_h, im_w, im_d = im.shape # im_h is maximum image height\n&gt;&gt;&gt; test = next(cv2.boundingRect(c) for c in get_contours(im, (50, 10)))\n&gt;&gt;&gt; x, y, w, h = test # see Slicing below\n&gt;&gt;&gt; ratio = y / im_h # `y` coordinate over `im_h` gives a pixel-based ratio\n&gt;&gt;&gt; page_point = ratio * page.height # equivalent point in PDF page\n</code></pre> <p>See related discussion.</p>"},{"location":"#boxes","title":"Boxes","text":""},{"location":"#slicing-opencv","title":"Slicing opencv","text":"<p>Rectangles for opencv</p> Reference Expectation Format Unit cv2.boundingRect() Results in a tuple of four points (<code>x</code>,<code>y</code>,<code>w</code>,<code>h</code>) pixels Fields Meaning <code>x</code> point in x-axis <code>y</code> point in y-axis <code>w</code> width <code>h</code> height"},{"location":"#slicing-pdfplumber","title":"Slicing pdfplumber","text":"<p>Rectangles for pdfplumber</p> Reference Expectation Format Unit pdfplumber._typing.T_bbox A tuple of four points (<code>x0</code>, <code>y0</code>, <code>x1</code>, <code>y1</code>) points Fields Meaning <code>x0</code> left-most point in x-axis <code>x1</code> right-most point in x-axis <code>y0</code> top-most point in y-axis <code>y1</code> bottom-most point in y-axis"},{"location":"#setup","title":"Setup","text":""},{"location":"#common-libraries","title":"Common libraries","text":"<p>Install common libraries in MacOS with <code>homebrew</code>:</p> Bash<pre><code>brew install tesseract\nbrew install imagemagick\nbrew info imagemagick # check version\n</code></pre> <p>The last command gets you the local folder installed which will be needed in creating the virtual environment:</p> Text Only<pre><code>==&gt; imagemagick: stable 7.1.0-59 (bottled), HEAD\nTools and libraries to manipulate images in many formats\nhttps://imagemagick.org/index.php\n/opt/homebrew/Cellar/imagemagick/7.1.0-60 (807 files, 31MB) * &lt;---- first part is the local folder\nx x x\n</code></pre> <p>Note that both <code>tesseract</code> and <code>imagemagick</code> libraries are also made preconditions in <code>.github/workflows/main.yaml</code>:</p> YAML<pre><code>steps:\n# see https://github.com/madmaze/pytesseract/blob/master/.github/workflows/ci.yaml\n- name: Install tesseract\nrun: sudo apt-get -y update &amp;&amp; sudo apt-get install -y tesseract-ocr tesseract-ocr-fra\n- name: Print tesseract version\nrun: echo $(tesseract --version)\n# see https://github.com/jsvine/pdfplumber/blob/stable/.github/workflows/tests.yml\n- name: Install ghostscript &amp; imagemagick\nrun: sudo apt update &amp;&amp; sudo apt install ghostscript libmagickwand-dev\n- name: Remove policy.xml\nrun: sudo rm /etc/ImageMagick-6/policy.xml # this needs to be removed or the test won't run\n</code></pre>"},{"location":"#virtual-environment","title":"Virtual environment","text":"<p>Update <code>.env</code> whenever <code>imagemagick</code> changes</p> <p>The shared dependency is based on <code>MAGICK_HOME</code> folder. This can't seem to be fetched by python (at least in 3.11) so we need to help it along by explicitly declaring its location. The folder can change when a new version is installed via <code>brew upgrade imagemagick</code></p> <p>Create an .env file and use the folder as the environment variable <code>MAGICK_HOME</code>:</p> Text Only<pre><code>MAGICK_HOME=/opt/homebrew/Cellar/imagemagick/7.1.0-60\n</code></pre> <p>This configuration will allow <code>pdfplumber</code> to detect <code>imagemagick</code>.</p> <p>Effect of not setting <code>MAGICK_HOME</code>:</p> Python<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; pdfplumber.open&lt;(testpath&gt;).pages[0].to_image(resolution=300) # ERROR\n</code></pre> Text Only<pre><code>OSError: cannot find library; tried paths: []\n\nDuring handling of the above exception, another exception occurred:\n\nImportError                               Traceback (most recent call last)\n...\nImportError: MagickWand shared library not found.\nYou probably had not installed ImageMagick library.\nTry to install:\n  brew install freetype imagemagick\n</code></pre> <p>With <code>MAGICK_HOME</code>:</p> Python<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; pdfplumber.open&lt;(testpath&gt;).pages[0].to_image\nPIL.Image.Image # image library and type detected\n</code></pre> <p>Proceed to create the environment using <code>poetry update</code> which will install the following into a separate virtual environment:</p> TOML<pre><code>[tool.poetry.dependencies]\npython = \"^3.11\"\npython-dotenv = \"^0.21\"\npdfplumber = \"^0.7.6\" # from pdf to txt\npillow = \"^9.4.0\" # from pdf to img\nopencv-python = \"^4.7.0.68\" # img manipulation\npytesseract = \"^0.3.10\" # map manipulated img\n</code></pre>"},{"location":"decision/","title":"Pages","text":""},{"location":"decision/#get_decision","title":"get_decision","text":"<p>From a pdf file, get metadata filled Decision with pages cropped into bodies and annexes until the terminal page.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; decision = get_decision(x)\n&gt;&gt;&gt; decision.category\n&lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n&gt;&gt;&gt; decision.composition\n&lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n&gt;&gt;&gt; decision.writer\n'CARPIO. J.:'\n&gt;&gt;&gt; isinstance(decision.pages[0].lines[0], Bodyline)\nTrue\n&gt;&gt;&gt; decision.pages[0].footnotes == [] # none found, # TODO: can't seem to detect\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Decision</code> <p>Instance of a Decision with pages populated</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def get_decision(path: Path) -&gt; Decision:\n\"\"\"From a pdf file, get metadata filled Decision with pages\n    cropped into bodies and annexes until the terminal page.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; decision = get_decision(x)\n        &gt;&gt;&gt; decision.category\n        &lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n        &gt;&gt;&gt; decision.composition\n        &lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n        &gt;&gt;&gt; decision.writer\n        'CARPIO. J.:'\n        &gt;&gt;&gt; isinstance(decision.pages[0].lines[0], Bodyline)\n        True\n        &gt;&gt;&gt; decision.pages[0].footnotes == [] # none found, # TODO: can't seem to detect\n        True\n    Args:\n        path (Path): Path to the pdf file.\n    Returns:\n        Self: Instance of a Decision with pages populated\n    \"\"\"  # noqa: E501\nmeta = DecisionMeta.prep(path)\nwith pdfplumber.open(path) as pdf:\ncaso = meta.init(pdf=pdf)\ncontent_pages = meta.add(pages=pdf.pages)\ncaso.pages.extend(content_pages)\nreturn caso\n</code></pre>"},{"location":"decision/#decisionmeta","title":"DecisionMeta","text":"<p>         Bases: <code>NamedTuple</code></p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>class DecisionMeta(NamedTuple):\nstart_index: int\nstart_page_num: int\nstart_indicator: PositionDecisionCategoryWriter | PositionNotice\nend_page_num: int\nend_page_pos: float | int\n@classmethod\ndef prep(cls, path: Path):\nif not (starter := get_start_page_pos(path)):\nraise Exception(\"Could not detect start of content.\")\nindex, start_indicator = starter\nif not start_indicator:\nraise Exception(\"Could not detect start indicator.\")\nender = get_end_page_pos(path)\nif not ender:\nraise Exception(\"Could not detect end of content.\")\nend_page_num, end_page_pos = ender\nreturn cls(\nstart_index=index,\nstart_page_num=index + 1,\nstart_indicator=start_indicator,\nend_page_num=end_page_num,\nend_page_pos=end_page_pos,\n)\ndef init(self, pdf: PDF) -&gt; Decision:\n\"\"\"Add the metadata of a Decision and extract the first page of the content\n        proper which will not necessarily be page 1.\n        Returns:\n            Decision: A Decision instance, if all elements match.\n        \"\"\"\nlogger.debug(f\"Initialize {self=}\")\nstart_page = pdf.pages[self.start_index]\nif isinstance(self.start_indicator, PositionNotice):\nreturn Decision(\ncomposition=PositionCourtComposition.from_pdf(pdf).element,\nnotice=True,\npages=[\nDecisionPage.extract_proper(\npage=start_page,\nstart_y=self.start_indicator.position_pct_height\n* start_page.height,\n)\n],\n)\nelif isinstance(self.start_indicator, PositionDecisionCategoryWriter):\nreturn Decision(\ncomposition=PositionCourtComposition.from_pdf(pdf).element,\ncategory=self.start_indicator.element,\nwriter=self.start_indicator.writer,\npages=[\nDecisionPage.extract_proper(\npage=start_page,\nstart_y=self.start_indicator.writer_pct_height\n* start_page.height,\n)\n],\n)\nraise Exception(\"Unexpected initialization of decision.\")\ndef add(self, pages: list[Page]) -&gt; Iterator[DecisionPage]:\nfor nxt in pages:\nif nxt.page_number &lt;= self.start_page_num:\ncontinue\nif nxt.page_number == self.end_page_num:\nlogger.debug(f\"Finalize {nxt.page_number=}.\")\nif page_valid := DecisionPage.extract_proper(\npage=nxt,\nend_y=self.end_page_pos,\n):\nyield page_valid\nelse:\nlogger.warning(\"Detected blank page.\")\nbreak\nelse:\nlogger.debug(f\"Initialize {nxt.page_number=}.\")\nif page_valid := DecisionPage.extract_proper(page=nxt):\nyield page_valid\nelse:\nlogger.warning(\"Detected blank page.\")\n</code></pre>"},{"location":"decision/#corpus_unpdf.DecisionMeta-functions","title":"Functions","text":""},{"location":"decision/#corpus_unpdf.decision.DecisionMeta.init","title":"<code>init(pdf)</code>","text":"<p>Add the metadata of a Decision and extract the first page of the content proper which will not necessarily be page 1.</p> <p>Returns:</p> Name Type Description <code>Decision</code> <code>Decision</code> <p>A Decision instance, if all elements match.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def init(self, pdf: PDF) -&gt; Decision:\n\"\"\"Add the metadata of a Decision and extract the first page of the content\n    proper which will not necessarily be page 1.\n    Returns:\n        Decision: A Decision instance, if all elements match.\n    \"\"\"\nlogger.debug(f\"Initialize {self=}\")\nstart_page = pdf.pages[self.start_index]\nif isinstance(self.start_indicator, PositionNotice):\nreturn Decision(\ncomposition=PositionCourtComposition.from_pdf(pdf).element,\nnotice=True,\npages=[\nDecisionPage.extract_proper(\npage=start_page,\nstart_y=self.start_indicator.position_pct_height\n* start_page.height,\n)\n],\n)\nelif isinstance(self.start_indicator, PositionDecisionCategoryWriter):\nreturn Decision(\ncomposition=PositionCourtComposition.from_pdf(pdf).element,\ncategory=self.start_indicator.element,\nwriter=self.start_indicator.writer,\npages=[\nDecisionPage.extract_proper(\npage=start_page,\nstart_y=self.start_indicator.writer_pct_height\n* start_page.height,\n)\n],\n)\nraise Exception(\"Unexpected initialization of decision.\")\n</code></pre>"},{"location":"decision/#decision","title":"Decision","text":"<p>Metadata of a pdf file parsed via <code>get_decision()</code></p> Field Description header The top portion of the page, usually excluded from metadata composition The composition of the Supreme Court that decided the case category When available, whether the case is a \"Decision\" or a \"Resolution\" writer When available, the writer of the case notice When True, means that there is no <code>category</code> available pages A list of Decision Pages with bodies/annexes Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@dataclass\nclass Decision:\n\"\"\"Metadata of a pdf file parsed via `get_decision()`\n    Field | Description\n    --:|:--\n    header | The top portion of the page, usually excluded from metadata\n    composition | The composition of the Supreme Court that decided the case\n    category | When available, whether the case is a \"Decision\" or a \"Resolution\"\n    writer | When available, the writer of the case\n    notice | When True, means that there is no `category` available\n    pages | A list of [Decision Pages with bodies/annexes][decision-page]\n    \"\"\"\ncomposition: CourtCompositionChoices\ncategory: DecisionCategoryChoices | None = None\nheader: CroppedPage | None = None\nwriter: str | None = None\nnotice: bool = False\npages: list[DecisionPage] = field(default_factory=list)\n</code></pre>"},{"location":"decision/#decision-page","title":"Decision Page","text":"<p>Metadata of a single page of the pdf file parsed via <code>get_decision()</code></p> Field Description <code>page_num</code> The page number of the Decision page <code>body</code> The main content above the annex, if existing <code>lines</code> Segments of the <code>body</code>'s text in the given <code>page_num</code> <code>annex</code> Portion of page containing the footnotes; some pages are annex-free <code>footnotes</code> Each footnote item in the <code>annex</code>'s text in the given <code>page_num</code> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@dataclass\nclass DecisionPage:\n\"\"\"Metadata of a single page of the pdf file parsed via `get_decision()`\n    Field | Description\n    --:|:--\n    `page_num` | The page number of the Decision page\n    `body` | The main content above the annex, if existing\n    `lines` | Segments of the `body`'s text in the given `page_num`\n    `annex` | Portion of page containing the footnotes; some pages are annex-free\n    `footnotes` | Each footnote item in the `annex`'s text in the given `page_num`\n    \"\"\"\npage_num: int\nbody: CroppedPage\nannex: CroppedPage | None = None\nlines: list[Bodyline] = field(default_factory=list)\nfootnotes: list[Footnote] = field(default_factory=list)\ndef __post_init__(self):\nself.lines = Bodyline.from_cropped(self.body)\nif self.annex:\nself.footnotes = Footnote.from_cropped(self.annex)\n@classmethod\ndef extract_proper(\ncls,\npage: Page,\nstart_y: float | int | None = None,\nend_y: float | int | None = None,\n) -&gt; Self:\n\"\"\"\n        The presence of a `header_line` and a `page_endline` determine\n        what to extract from a given `page`.\n        The `header_line` is the imaginary line at the top of the page.\n        If the `start_y` is supplied, it means that the `header_line`\n        no longer needs to be calculated.\n        The `page_line` is the imaginary line at the bottom of the page\n        If the `end_y` is supplied, it means that the calculated `page_line`\n        ought to be replaced.\n        Args:\n            page (Page): The pdfplumber page to evaluate\n            start_y (float | int | None, optional): If present, refers to\n                The y-axis point of the starter page. Defaults to None.\n            end_y (float | int | None, optional): If present, refers to\n                The y-axis point of the ender page. Defaults to None.\n        Returns:\n            Self: Page with individual components mapped out.\n        \"\"\"\nim = get_img_from_page(page)\nheader_line = start_y or get_header_line(im, page)\nif not header_line:\nraise _err(page, \"No header line\")\nend_of_content, e = get_page_end(im, page)\npage_line = end_y or end_of_content\npage_num = get_page_num(page, header_line) or 0\nbody = PageCut.set(page=page, y0=header_line, y1=page_line)\nannex = PageCut.set(page=page, y0=end_of_content, y1=e) if e else None\nreturn cls(page_num=page_num, body=body, annex=(annex))\n</code></pre>"},{"location":"decision/#corpus_unpdf.DecisionPage-functions","title":"Functions","text":""},{"location":"decision/#corpus_unpdf.decision.DecisionPage.extract_proper","title":"<code>extract_proper(page, start_y=None, end_y=None)</code>  <code>classmethod</code>","text":"<p>The presence of a <code>header_line</code> and a <code>page_endline</code> determine what to extract from a given <code>page</code>.</p> <p>The <code>header_line</code> is the imaginary line at the top of the page. If the <code>start_y</code> is supplied, it means that the <code>header_line</code> no longer needs to be calculated.</p> <p>The <code>page_line</code> is the imaginary line at the bottom of the page If the <code>end_y</code> is supplied, it means that the calculated <code>page_line</code> ought to be replaced.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>The pdfplumber page to evaluate</p> required <code>start_y</code> <code>float | int | None</code> <p>If present, refers to The y-axis point of the starter page. Defaults to None.</p> <code>None</code> <code>end_y</code> <code>float | int | None</code> <p>If present, refers to The y-axis point of the ender page. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Page with individual components mapped out.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@classmethod\ndef extract_proper(\ncls,\npage: Page,\nstart_y: float | int | None = None,\nend_y: float | int | None = None,\n) -&gt; Self:\n\"\"\"\n    The presence of a `header_line` and a `page_endline` determine\n    what to extract from a given `page`.\n    The `header_line` is the imaginary line at the top of the page.\n    If the `start_y` is supplied, it means that the `header_line`\n    no longer needs to be calculated.\n    The `page_line` is the imaginary line at the bottom of the page\n    If the `end_y` is supplied, it means that the calculated `page_line`\n    ought to be replaced.\n    Args:\n        page (Page): The pdfplumber page to evaluate\n        start_y (float | int | None, optional): If present, refers to\n            The y-axis point of the starter page. Defaults to None.\n        end_y (float | int | None, optional): If present, refers to\n            The y-axis point of the ender page. Defaults to None.\n    Returns:\n        Self: Page with individual components mapped out.\n    \"\"\"\nim = get_img_from_page(page)\nheader_line = start_y or get_header_line(im, page)\nif not header_line:\nraise _err(page, \"No header line\")\nend_of_content, e = get_page_end(im, page)\npage_line = end_y or end_of_content\npage_num = get_page_num(page, header_line) or 0\nbody = PageCut.set(page=page, y0=header_line, y1=page_line)\nannex = PageCut.set(page=page, y0=end_of_content, y1=e) if e else None\nreturn cls(page_num=page_num, body=body, annex=(annex))\n</code></pre>"},{"location":"document/","title":"Document Reference","text":""},{"location":"document/#content","title":"Content","text":""},{"location":"document/#start-of-content","title":"Start of Content","text":"<p>Although the collection of pages has a logical start page, this exceptionally does not correspond to the actual start of the content.</p> <p>The actual start of content depends on either the detection of a Notice or a Category</p> <p>This requires searching the page from start to finish, via <code>get_pages_and_imgs()</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n&gt;&gt;&gt; res = get_start_page_pos(x)\n&gt;&gt;&gt; type(res[0])\n&lt;class 'int'&gt;\n&gt;&gt;&gt; res[0]\n0\n&gt;&gt;&gt; type(res[1])\n&lt;class 'corpus_unpdf.src.content_markers.PositionNotice'&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the PDF file.</p> required <p>Returns:</p> Type Description <code>tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None</code> <p>tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None: The zero-based index of the page (i.e. 0 = page 1), the marker found that signifies start of the content</p> Source code in <code>corpus_unpdf/src/content_starter.py</code> Python<pre><code>def get_start_page_pos(\npath: Path,\n) -&gt; tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None:\n\"\"\"Although the collection of pages has a logical start page, this\n    _exceptionally_ does not correspond to the actual start of the content.\n    The actual start of content depends on either the detection of a\n    Notice or a Category\n    This requires searching the page from start to finish, via\n    `get_pages_and_imgs()`\n    Examples:\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n        &gt;&gt;&gt; res = get_start_page_pos(x)\n        &gt;&gt;&gt; type(res[0])\n        &lt;class 'int'&gt;\n        &gt;&gt;&gt; res[0]\n        0\n        &gt;&gt;&gt; type(res[1])\n        &lt;class 'corpus_unpdf.src.content_markers.PositionNotice'&gt;\n    Args:\n        path (Path): Path to the PDF file.\n    Returns:\n        tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None:\n            The zero-based index of the page (i.e. 0 = page 1), the marker found that\n            signifies start of the content\n    \"\"\"\nfor page, im in get_pages_and_imgs(path):\nindex = page.page_number - 1  # represents the 0-based index\n_, im_w, _ = im.shape\nMIDPOINT = im_w / 2\nfor cnt in get_contours(im, (30, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\none_liner = h &lt; 100\nx_start_mid = x &lt; MIDPOINT\nx_end_mid = (x + w) &gt; MIDPOINT\nshort_width = 200 &lt; w &lt; 800\nif all([one_liner, x_start_mid, x_end_mid, short_width]):\nsliced = im[y : y + h, x : x + w]\n# cv2.rectangle(im, (x, y), (x + w, y + h), (36, 255, 12), 3)\n# print(f\"{x=}, {y=}, {w=}, {h=}\")\nif is_match_text(sliced, \"notice\"):\nreturn index, PositionNotice.extract(im)\nelif is_match_text(sliced, \"decision\"):\nreturn index, PositionDecisionCategoryWriter.extract(im)\nelif is_match_text(sliced, \"resolution\"):\nreturn index, PositionDecisionCategoryWriter.extract(im)\n# cv2.imwrite(f\"temp/sample_boxes-{page.page_number}.png\", im)\nreturn None\n</code></pre> <p>In relation, see:</p> <p>Get the page and images in sequential order.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; results = get_pages_and_imgs(x)\n&gt;&gt;&gt; result = next(results)\n&gt;&gt;&gt; type(result)\n&lt;class 'tuple'&gt;\n&gt;&gt;&gt; isinstance(result[0], Page)\nTrue\n&gt;&gt;&gt; assert result[0].page_number == 1 # first\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>Page | Path</code> <p>Path to the PDF file.</p> required <p>Yields:</p> Type Description <code>Iterator[tuple[Page, numpy.ndarray]]</code> <p>Iterator[tuple[Page, numpy.ndarray]]: Pages with respective images</p> Source code in <code>corpus_unpdf/src/common/fetch.py</code> Python<pre><code>def get_pages_and_imgs(\npdfpath: str | Path,\n) -&gt; Iterator[tuple[Page, numpy.ndarray]]:\n\"\"\"Get the page and images in sequential order.\n    Examples:\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; results = get_pages_and_imgs(x)\n        &gt;&gt;&gt; result = next(results)\n        &gt;&gt;&gt; type(result)\n        &lt;class 'tuple'&gt;\n        &gt;&gt;&gt; isinstance(result[0], Page)\n        True\n        &gt;&gt;&gt; assert result[0].page_number == 1 # first\n    Args:\n        pdfpath (Page | Path): Path to the PDF file.\n    Yields:\n        Iterator[tuple[Page, numpy.ndarray]]: Pages with respective images\n    \"\"\"\nwith pdfplumber.open(pdfpath) as pdf:\nindex = 0\nwhile index &lt; len(pdf.pages):\npage = pdf.pages[index]\nyield page, get_img_from_page(page)\nindex += 1\n</code></pre>"},{"location":"document/#end-of-content","title":"End of Content","text":"<p>Although the collection of pages has a logical end page, this oftentimes does not correspond to the actual end of the content.</p> <p>The actual end of content depends on either two pieces of text: the <code>Ordered</code> clause or <code>By Authority of the Court</code></p> <p>This requires searching the page in reverse, via <code>get_reverse_pages_and_imgs()</code> since the above pieces of text indicate the end of the content.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n&gt;&gt;&gt; get_end_page_pos(x) # page 5, y-axis 80.88\n(5, 80.88)\n</code></pre> <p>Also see snippets for debugging:</p> Python<pre><code>debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\ncv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\ncv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the PDF file.</p> required <p>Returns:</p> Type Description <code>tuple[int, int] | None</code> <p>tuple[int, int] | None: The page number from pdfplumber.pages, the Y position of that page</p> Source code in <code>corpus_unpdf/src/content_ender.py</code> Python<pre><code>def get_end_page_pos(path: Path) -&gt; tuple[int, int] | None:\n\"\"\"Although the collection of pages has a logical end page, this\n    oftentimes does not correspond to the actual end of the content.\n    The actual end of content depends on either two pieces of text:\n    the `Ordered` clause or `By Authority of the Court`\n    This requires searching the page in reverse, via\n    `get_reverse_pages_and_imgs()` since the above pieces of text\n    indicate the end of the content.\n    Examples:\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n        &gt;&gt;&gt; get_end_page_pos(x) # page 5, y-axis 80.88\n        (5, 80.88)\n    Also see snippets for debugging:\n    ```py\n    debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\n    cv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\n    cv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n    ```\n    Args:\n        path (Path): Path to the PDF file.\n    Returns:\n        tuple[int, int] | None: The page number from pdfplumber.pages, the Y position\n            of that page\n    \"\"\"\nORDERED, AUTHORITY = \"so ordered\", \"by authority of the court\"\nfor page, im in get_reverse_pages_and_imgs(path):\nim_h, im_w, _ = im.shape\nMIDPOINT = im_w / 2\nfor cnt in get_contours(im, (30, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\nsliced_im = im[y : y + h, x : x + w]\noutput = page.page_number, (y / im_h) * page.height\nif h &lt; 100:\nif x &lt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=ORDERED,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nelif x &gt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=AUTHORITY,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nreturn None\n</code></pre> <p>In relation, see:</p> <p>Start from the end page to get to the first page to determine terminal values.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; results = get_reverse_pages_and_imgs(x)\n&gt;&gt;&gt; result = next(results)\n&gt;&gt;&gt; type(result)\n&lt;class 'tuple'&gt;\n&gt;&gt;&gt; isinstance(result[0], Page)\nTrue\n&gt;&gt;&gt; assert result[0].page_number == len(pdfplumber.open(x).pages) # last first\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>Page | Path</code> <p>Path to the PDF file.</p> required <p>Yields:</p> Type Description <code>Iterator[tuple[Page, numpy.ndarray]]</code> <p>Iterator[tuple[Page, numpy.ndarray]]: Pages with respective images</p> Source code in <code>corpus_unpdf/src/common/fetch.py</code> Python<pre><code>def get_reverse_pages_and_imgs(\npdfpath: str | Path,\n) -&gt; Iterator[tuple[Page, numpy.ndarray]]:\n\"\"\"Start from the end page to get to the first page\n    to determine terminal values.\n    Examples:\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; results = get_reverse_pages_and_imgs(x)\n        &gt;&gt;&gt; result = next(results)\n        &gt;&gt;&gt; type(result)\n        &lt;class 'tuple'&gt;\n        &gt;&gt;&gt; isinstance(result[0], Page)\n        True\n        &gt;&gt;&gt; assert result[0].page_number == len(pdfplumber.open(x).pages) # last first\n    Args:\n        pdfpath (Page | Path): Path to the PDF file.\n    Yields:\n        Iterator[tuple[Page, numpy.ndarray]]: Pages with respective images\n    \"\"\"\nwith pdfplumber.open(pdfpath) as pdf:\nindex = len(pdf.pages) - 1\nwhile index &gt;= 0:\npage = pdf.pages[index]\nyield page, get_img_from_page(page)\nindex -= 1\n</code></pre>"},{"location":"document/#page","title":"Page","text":""},{"location":"document/#header-of-page","title":"Header of Page","text":""},{"location":"document/#page-y-axis-start","title":"Page Y-Axis Start","text":"<p>The header represents non-title page content above the main content.</p> <p>The terminating header line is a non-visible line that separates the decision's header from its main content. We'll use a typographic bottom of the header to signify this line.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 1 marks the second page\n&gt;&gt;&gt; get_header_line(im, page)\n75.12\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The full page image</p> required <code>page</code> <code>Page</code> <p>The pdfplumber page</p> required <p>Returns:</p> Type Description <code>int | float | None</code> <p>float | None: Y-axis point (pdfplumber point) at bottom of header</p> Source code in <code>corpus_unpdf/src/page_header.py</code> Python<pre><code>def get_header_line(im: numpy.ndarray, page: Page) -&gt; int | float | None:\n\"\"\"The header represents non-title page content above the main content.\n    The terminating header line is a non-visible line that separates the\n    decision's header from its main content. We'll use a typographic bottom\n    of the [header][docket-coordinates] to signify this line.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 1 marks the second page\n        &gt;&gt;&gt; get_header_line(im, page)\n        75.12\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        im (numpy.ndarray): The full page image\n        page (Page): The pdfplumber page\n    Returns:\n        float | None: Y-axis point (pdfplumber point) at bottom of header\n    \"\"\"\nim_h, _, _ = im.shape\nif hd := get_header_docket_coordinates(im):\n_, y, _, h = hd\nheader_end = (y + h) / im_h\nterminal = header_end * page.height\nreturn terminal\nreturn None\n</code></pre>"},{"location":"document/#docket-coordinates","title":"Docket Coordinates","text":"<p>The header represents non-title page content above the main content.</p> <p>It usually consists of three items:</p> Item Label Example 1 Type of decision <code>Resolution</code> or <code>Decision</code> 2 Page number 1, 2, 3, etc. 3 Docket of the decision involved GR. 12414, Dec. 1, 2023 <p>This detects Item (3) which implies that it is the in upper right quarter of the document:</p> Python<pre><code>x &gt; im_w / 2 # ensures that it is on the right side of the page\ny &lt;= im_h * 0.2 # ensures that it is on the top quarter of the page\n</code></pre> <p>Item (3) is the only one above that is likely to have a second vertical line, hence choosing this as the the typographic bottom for the header makes sense.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 0 marks the second page\n&gt;&gt;&gt; get_header_docket_coordinates(im)\n(1813, 229, 460, 84)\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The full page image</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int, int] | None</code> <p>tuple[int, int, int, int] | None: The coordinates of the docket, if found.</p> Source code in <code>corpus_unpdf/src/page_header.py</code> Python<pre><code>def get_header_docket_coordinates(\nim: numpy.ndarray,\n) -&gt; tuple[int, int, int, int] | None:\n\"\"\"The header represents non-title page content above the main content.\n    It usually consists of three items:\n    Item | Label | Example\n    --:|:--|:--\n    1 | Type of decision | `Resolution` or `Decision`\n    2 | Page number | 1, 2, 3, etc.\n    3 | Docket of the decision involved | GR. 12414, Dec. 1, 2023\n    This detects Item (3) which implies that it is the in upper right quarter\n    of the document:\n    ```py\n    x &gt; im_w / 2 # ensures that it is on the right side of the page\n    y &lt;= im_h * 0.2 # ensures that it is on the top quarter of the page\n    ```\n    Item (3) is the only one above that is likely to have a second vertical line,\n    hence choosing this as the the typographic bottom for the header makes sense.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 0 marks the second page\n        &gt;&gt;&gt; get_header_docket_coordinates(im)\n        (1813, 229, 460, 84)\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        im (numpy.ndarray): The full page image\n    Returns:\n        tuple[int, int, int, int] | None: The coordinates of the docket, if found.\n    \"\"\"\nim_h, im_w, _ = im.shape\nfor cnt in get_contours(im, (50, 50)):\nx, y, w, h = cv2.boundingRect(cnt)\nif x &gt; im_w / 2 and y &lt;= im_h * 0.25 and w &gt; 200:\nreturn x, y, w, h\nreturn None\n</code></pre>"},{"location":"document/#page-number","title":"Page Number","text":"<p>Get the first matching digit in the header's text. This helps deal with decisions having blank pages.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_img_from_page\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; pdf = pdfplumber.open(x)\n&gt;&gt;&gt; page = pdf.pages[1] # page 2\n&gt;&gt;&gt; im = get_img_from_page(page)\n&gt;&gt;&gt; header_line = get_header_line(im, page)\n&gt;&gt;&gt; get_page_num(page, header_line)\n2\n&gt;&gt;&gt; pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>The pdfplumber page</p> required <code>header_line</code> <code>int | float</code> <p>The value retrieved from <code>get_header_line()</code></p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: The page number, if found</p> Source code in <code>corpus_unpdf/src/page_header.py</code> Python<pre><code>def get_page_num(page: Page, header_line: int | float) -&gt; int | None:\n\"\"\"Get the first matching digit in the header's text. This helps\n    deal with decisions having blank pages.\n    Examples:\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_img_from_page\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; pdf = pdfplumber.open(x)\n        &gt;&gt;&gt; page = pdf.pages[1] # page 2\n        &gt;&gt;&gt; im = get_img_from_page(page)\n        &gt;&gt;&gt; header_line = get_header_line(im, page)\n        &gt;&gt;&gt; get_page_num(page, header_line)\n        2\n        &gt;&gt;&gt; pdf.close()\n    Args:\n        page (Page): The pdfplumber page\n        header_line (int | float): The value retrieved from `get_header_line()`\n    Returns:\n        int | None: The page number, if found\n    \"\"\"\nbox = (0, 0, page.width, header_line)\nheader = page.crop(box, relative=False, strict=True)\ntexts = header.extract_text(layout=True, keep_blank_chars=True).split()\nfor text in texts:\nif text.isdigit() and len(text) &lt;= 3:\nreturn int(text)\nreturn None\n</code></pre>"},{"location":"document/#footer-of-page","title":"Footer of Page","text":""},{"location":"document/#annex-existence-as-page-y-axis-ends","title":"Annex Existence as Page Y-Axis End/s","text":"<p>Given an <code>im</code>, detect the footnote line of the annex and return relevant points in the y-axis as a tuple.</p> Scenario Description y0 y1 Footnote line exists Page contains footnotes int or float int or float signifying end of page Footnote line absent Page does not contain footnotes int or float signifying end of page <code>None</code> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>the openCV image that may contain a footnote line</p> required <code>page</code> <code>Page</code> <p>the pdfplumber.page.Page based on <code>im</code></p> required <p>Returns:</p> Type Description <code>tuple[float, float | None]</code> <p>tuple[float, float | None]: The annex line's y-axis (if it exists) and The page's end content line</p> Source code in <code>corpus_unpdf/src/page_footer.py</code> Python<pre><code>def get_page_end(im: numpy.ndarray, page: Page) -&gt; tuple[float, float | None]:\n\"\"\"Given an `im`, detect the footnote line of the annex and return\n    relevant points in the y-axis as a tuple.\n    Scenario | Description | y0 | y1\n    :--:|:-- |:--:|:--:\n    Footnote line exists | Page contains footnotes | int or float | int or float signifying end of page\n    Footnote line absent | Page does not contain footnotes | int or float signifying end of page | `None`\n    Args:\n        im (numpy.ndarray): the openCV image that may contain a footnote line\n        page (Page): the pdfplumber.page.Page based on `im`\n    Returns:\n        tuple[float, float | None]: The annex line's y-axis (if it exists) and\n            The page's end content line\n    \"\"\"  # noqa: E501\nim_h, _, _ = im.shape\nfn = get_footer_line_coordinates(im)\ny1 = PERCENT_OF_MAX_PAGE * page.height\nif fn:\n_, y, _, _ = fn\nfn_line_end = y / im_h\ny0 = fn_line_end * page.height\nreturn y0, y1\nreturn y1, None\n</code></pre>"},{"location":"document/#footer-line-coordinates","title":"Footer Line Coordinates","text":"<p>The footer represents content below the main content. This is also called the annex of the page.</p> <p>This detects a short line in the lower half of the page that has at least a width of 400 pixels and a height of less than 40 pixels, indicating a narrow box (as dilated by openCV). Text found below this box represents the annex.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 0 marks the second page\n&gt;&gt;&gt; get_footer_line_coordinates(im)\n(426, 3148, 499, 13)\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The full page image</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int, int] | None</code> <p>tuple[int, int, int, int] | None: The coordinates of the footer line, if found.</p> Source code in <code>corpus_unpdf/src/page_footer.py</code> Python<pre><code>def get_footer_line_coordinates(\nim: numpy.ndarray,\n) -&gt; tuple[int, int, int, int] | None:\n\"\"\"The footer represents content below the main content. This is also\n    called the annex of the page.\n    This detects a short line in the lower half of the page that has at least a width\n    of 400 pixels and a height of less than 40 pixels, indicating a narrow box\n    (as dilated by openCV). Text found below this box represents the annex.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 1) # 0 marks the second page\n        &gt;&gt;&gt; get_footer_line_coordinates(im)\n        (426, 3148, 499, 13)\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        im (numpy.ndarray): The full page image\n    Returns:\n        tuple[int, int, int, int] | None: The coordinates of the footer line, if found.\n    \"\"\"\nim_h, im_w, _ = im.shape\nfor c in get_contours(im, (50, 10)):\nx, y, w, h = cv2.boundingRect(c)\nx0_on_left_side = x &lt; (im_w / 2)\nx1_on_left_side = (x + w) &lt; (im_w / 2)\nshort_line = (im_w / 2) &gt; w &gt; 400\nshort_height = h &lt; 50\nif all([short_line, x0_on_left_side, x1_on_left_side, short_height]):\n# cv2.rectangle(im, (x, y), (x + w, y + h), (36, 255, 12), 3)\n# cv2.imwrite(\"temp/sample_boxes.png\", im)\nreturn x, y, w, h\nreturn None\n</code></pre>"},{"location":"markers/","title":"Markers","text":"<p>Typically used in the first page of a Decision document to determine the positions of Y-coordinates and to extract the metadata associated with the page.</p>"},{"location":"markers/#court-composition","title":"Court Composition","text":""},{"location":"markers/#composition-choices","title":"Composition Choices","text":"<p>         Bases: <code>Enum</code></p> <p>How the Supreme Court sits. At present, this includes four options. Might need to add cases for special divisions.</p> Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class CourtCompositionChoices(Enum):\n\"\"\"How the Supreme Court sits. At present, this includes four\n    options. Might need to add cases for _special_ divisions.\"\"\"\nENBANC = \"En Banc\"\nDIV1 = \"First Division\"\nDIV2 = \"Second Division\"\nDIV3 = \"Third Division\"\n</code></pre>"},{"location":"markers/#extract-composition","title":"Extract Composition","text":"<p>         Bases: <code>NamedTuple</code></p> Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class PositionCourtComposition(NamedTuple):\nelement: CourtCompositionChoices\ncoordinates: tuple[int, int, int, int]\ncomposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in CourtCompositionChoices:\nif xywh := get_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\ncomposition_pct_height=(y + h) / im_h,\n)\nreturn None\n@classmethod\ndef from_pdf(cls, pdf: PDF) -&gt; Self:\npage_one_im = get_img_from_page(pdf.pages[0])\ncourt_composition = cls.extract(page_one_im)\nif not court_composition:\nraise Exception(\"Could not detect court compositon in page 1.\")\nreturn court_composition\n</code></pre>"},{"location":"markers/#decision-category-writer","title":"Decision Category &amp; Writer","text":""},{"location":"markers/#category-choices","title":"Category Choices","text":"<p>         Bases: <code>Enum</code></p> <p>The classification of a decision issued by the Supreme Court.</p> Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class DecisionCategoryChoices(Enum):\n\"\"\"The classification of a decision issued by the Supreme Court.\"\"\"\nCASO = \"Decision\"\nRESO = \"Resolution\"\n</code></pre>"},{"location":"markers/#extract-category","title":"Extract Category","text":"<p>         Bases: <code>NamedTuple</code></p> Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class PositionDecisionCategoryWriter(NamedTuple):\nelement: DecisionCategoryChoices\ncoordinates: tuple[int, int, int, int]\nwriter: str\ncategory_pct_height: float\nwriter_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in DecisionCategoryChoices:\nif xywh := get_centered_coordinates(im, member.value):\n_, y, _, h = xywh\ny0, y1 = y + h, y + 270\nwriter_box = im[y0:y1]\nreturn cls(\nelement=member,\ncoordinates=xywh,\nwriter=pytesseract.image_to_string(writer_box).strip(),\ncategory_pct_height=y / im_h,\nwriter_pct_height=y1 / im_h,\n)\nreturn None\n</code></pre>"},{"location":"markers/#notice","title":"Notice","text":"<p>         Bases: <code>NamedTuple</code></p> <p>When present, signifies that this was issued by authority of the Court.</p> Source code in <code>corpus_unpdf/src/content_markers.py</code> Python<pre><code>class PositionNotice(NamedTuple):\n\"\"\"When present, signifies that this was issued by authority of the Court.\"\"\"\nelement: NoticeChoices\ncoordinates: tuple[int, int, int, int]\nposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in NoticeChoices:\nif xywh := get_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\nposition_pct_height=(y + h) / im_h,\n)\nreturn None\n</code></pre>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#fetch-pdfs","title":"Fetch PDFs","text":"<p>Work with pdf files.</p>"},{"location":"utils/#extract-page-image","title":"Extract page, image","text":"<p>Combines <code>OpenCV</code> with <code>pdfplumber</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 0) # 0 marks the first page\n&gt;&gt;&gt; page.page_number # the first page\n1\n&gt;&gt;&gt; isinstance(page, Page)\nTrue\n&gt;&gt;&gt; isinstance(im, numpy.ndarray)\nTrue\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>str | Path</code> <p>Path to the PDF file.</p> required <code>index</code> <code>int</code> <p>Zero-based index that determines the page number.</p> required <p>Returns:</p> Type Description <code>tuple[Page, numpy.ndarray]</code> <p>tuple[Page, numpy.ndarray]: Page identified by <code>index</code>  with image of the page  (in numpy format) that can be manipulated.</p> Source code in <code>corpus_unpdf/src/common/fetch.py</code> Python<pre><code>def get_page_and_img(\npdfpath: str | Path, index: int\n) -&gt; tuple[Page, numpy.ndarray]:\n\"\"\"Combines `OpenCV` with `pdfplumber`.\n    Examples:\n        &gt;&gt;&gt; import numpy\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 0) # 0 marks the first page\n        &gt;&gt;&gt; page.page_number # the first page\n        1\n        &gt;&gt;&gt; isinstance(page, Page)\n        True\n        &gt;&gt;&gt; isinstance(im, numpy.ndarray)\n        True\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        pdfpath (str | Path): Path to the PDF file.\n        index (int): Zero-based index that determines the page number.\n    Returns:\n        tuple[Page, numpy.ndarray]: Page identified by `index`  with image of the\n            page  (in numpy format) that can be manipulated.\n    \"\"\"\nwith pdfplumber.open(pdfpath) as pdf:\npage = pdf.pages[index]\nimg = get_img_from_page(page)\nreturn page, img\n</code></pre>"},{"location":"utils/#slice-images-pages","title":"Slice images &amp; pages","text":"<p>Using pre-processed PDF files above, slice images and/or pages based on certain criteria.</p>"},{"location":"utils/#get-contours-from-image","title":"Get contours from image","text":"<p>Generally follows the strategy outlined here:</p> <ol> <li>Youtube video</li> <li>Stack Overflow answer</li> </ol> <p>The structuring element used will be a rectangle of dimensions specified in <code>rectangle_size</code> (w, h). After dilating the image, the contours can be enumerated for further processing and matching, e.g. after the image is transformed, can find which lines appear in the center or in the top right quadrant, etc.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The opencv formatted image</p> required <code>rectangle_size</code> <code>tuple[int, int]</code> <p>The width and height to morph the characters</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The contours found based on the specified structuring element</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>def get_contours(im: numpy.ndarray, rectangle_size: tuple[int, int]) -&gt; list:\n\"\"\"Generally follows the strategy outlined here:\n    1. [Youtube video](https://www.youtube.com/watch?v=ZeCRe9sNFwk&amp;list=PL2VXyKi-KpYuTAZz__9KVl1jQz74bDG7i&amp;index=11)\n    2. [Stack Overflow answer](https://stackoverflow.com/a/57262099)\n    The structuring element used will be a rectangle of dimensions\n    specified in `rectangle_size` (w, h). After dilating the image,\n    the contours can be enumerated for further processing and\n    matching, e.g. after the image is transformed, can find\n    which lines appear in the center or in the top right quadrant, etc.\n    Args:\n        im (numpy.ndarray): The opencv formatted image\n        rectangle_size (tuple[int, int]): The width and height to morph the characters\n    Returns:\n        list: The contours found based on the specified structuring element\n    \"\"\"  # noqa: E501\ngray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray, (7, 7), 0)\nthresh = cv2.threshold(\nblur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU\n)[1]\nkernel = cv2.getStructuringElement(cv2.MORPH_RECT, rectangle_size)\ndilate = cv2.dilate(thresh, kernel, iterations=1)\ncv2.imwrite(\"temp/sample_dilated.png\", dilate)\ncnts = cv2.findContours(dilate, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\ncnts = cnts[0] if len(cnts) == 2 else cnts[1]\nreturn sorted(cnts, key=lambda x: cv2.boundingRect(x)[1])\n</code></pre>"},{"location":"utils/#test-image-matches-text","title":"Test image matches text","text":"<p>Test whether textual image in <code>sliced_im</code> resembles <code>text_to_match</code> by a <code>likelihood</code> percentage.</p> <p>Parameters:</p> Name Type Description Default <code>sliced_im</code> <code>numpy.ndarray</code> <p>Slice of a larger image containing text</p> required <code>text_to_match</code> <code>str</code> <p>How to match the text slice in <code>im</code></p> required <code>likelihood</code> <code>float</code> <p>Allowed percentage expressed in decimals</p> <code>0.7</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether or not the <code>text_to_match</code> resembles <code>sliced_im</code>'s text.</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>def is_match_text(\nsliced_im: numpy.ndarray,\ntext_to_match: str,\nlikelihood: float = 0.7,\n) -&gt; bool:\n\"\"\"Test whether textual image in `sliced_im` resembles `text_to_match` by\n    a `likelihood` percentage.\n    Args:\n        sliced_im (numpy.ndarray): Slice of a larger image containing text\n        text_to_match (str): How to match the text slice in `im`\n        likelihood (float): Allowed percentage expressed in decimals\n    Returns:\n        bool: Whether or not the `text_to_match` resembles `sliced_im`'s text.\n    \"\"\"\nupper_candidate = pytesseract.image_to_string(sliced_im).strip().upper()\nupper_matcher = text_to_match.upper()\nmatch = SequenceMatcher(None, a=upper_candidate, b=upper_matcher)\nreturn match.ratio() &gt; likelihood\n</code></pre>"},{"location":"utils/#centered-text-matching-contours","title":"Centered text matching contours","text":"<p>With a image <code>im</code>, get all contours found in the center of the image and then for each of these matches, if they are text resembling <code>text_to_match</code>, extract the coordinates of such contours.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 0)\n&gt;&gt;&gt; get_centered_coordinates(im, 'Decision') # None found\n&gt;&gt;&gt; get_centered_coordinates(im, 'Resolution')\n(1068, 2108, 564, 92)\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>numpy.ndarray</code> <p>The base image to look for text</p> required <code>text_to_match</code> <code>str</code> <p>The words that should match</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int, int] | None</code> <p>tuple[int, int, int, int] | None: (x, y, w, h) pixels representing <code>cv2.boundingRect</code>, if found.</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>def get_centered_coordinates(\nim: numpy.ndarray, text_to_match: str\n) -&gt; tuple[int, int, int, int] | None:\n\"\"\"With a image `im`, get all contours found in the center\n    of the image and then for each of these matches, if they\n    are text resembling `text_to_match`, extract the coordinates of\n    such contours.\n    Examples:\n        &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; page, im = get_page_and_img(x, 0)\n        &gt;&gt;&gt; get_centered_coordinates(im, 'Decision') # None found\n        &gt;&gt;&gt; get_centered_coordinates(im, 'Resolution')\n        (1068, 2108, 564, 92)\n        &gt;&gt;&gt; page.pdf.close()\n    Args:\n        im (numpy.ndarray): The base image to look for text\n        text_to_match (str): The words that should match\n    Returns:\n        tuple[int, int, int, int] | None: (x, y, w, h) pixels representing\n            `cv2.boundingRect`, if found.\n    \"\"\"\n_, im_w, _ = im.shape\nfor cnt in get_contours(im, (50, 50)):\nx, y, w, h = cv2.boundingRect(cnt)\nx0_mid_left = (1 * im_w) / 4 &lt; x\nendpoint_on_right = x + w &gt; im_w / 2\nshort_width = w &gt; 200\nif all([x0_mid_left, endpoint_on_right, short_width]):\n# cv2.rectangle(im, (x, y), (x + w, y + h), (36, 255, 12), 3)\n# cv2.imwrite(\"temp/sample_boxes.png\", im)\nif is_match_text(\nsliced_im=im[y : y + h, x : x + w],\ntext_to_match=text_to_match,\nlikelihood=0.7,\n):\nreturn x, y, w, h\nreturn None\n</code></pre>"},{"location":"utils/#get-slice-of-page","title":"Get slice of page","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Fields:</p> field type description page pdfplumber.page.Page The page to cut x0 float or int The x axis where the slice will start x1 float or int The x axis where the slice will terminate y0 float or int The y axis where the slice will start y1 float or int The y axis where the slice will terminate <p>When the above fields are populated, the <code>@slice</code> property describes the area of the page that will be used to extract text from.</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>class PageCut(NamedTuple):\n\"\"\"Fields:\n    field | type | description\n    --:|:--|:--\n    page | pdfplumber.page.Page | The page to cut\n    x0 | float or int | The x axis where the slice will start\n    x1 | float or int | The x axis where the slice will terminate\n    y0 | float or int | The y axis where the slice will start\n    y1 | float or int | The y axis where the slice will terminate\n    When the above fields are populated, the `@slice` property describes\n    the area of the page that will be used to extract text from.\n    \"\"\"\npage: Page\nx0: float | int\nx1: float | int\ny0: float | int\ny1: float | int\n@property\ndef slice(self) -&gt; CroppedPage:\n\"\"\"Unlike slicing from an image based on a `numpy.ndarray`, a page cut\n        implies a page derived from `pdfplumber`. The former is based on pixels;\n        the latter on points.\n        Examples:\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n            &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n            &gt;&gt;&gt; page, im = get_page_and_img(x, 0) # page 1\n            &gt;&gt;&gt; page.height\n            948.72\n            &gt;&gt;&gt; cutpage = PageCut(page=page, x0=100, x1=200, y0=100, y1=200).slice\n            &gt;&gt;&gt; cutpage.height\n            100\n            &gt;&gt;&gt; page.pdf.close()\n        Returns:\n            CroppedPage: The page crop where to extract text from.\n        \"\"\"\nbox: T_bbox = (self.x0, self.y0, self.x1, self.y1)\nreturn self.page.crop(box, relative=False, strict=True)\n@classmethod\ndef set(cls, page: Page, y0: float | int, y1: float | int) -&gt; CroppedPage:\n\"\"\"Using a uniform margin on the x-axis, supply the page\n        to generate page width and thus force preset margins. The `y0`\n        and `y1` fields determine how to slice the page.\n        Examples:\n            &gt;&gt;&gt; import pdfplumber\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_img_from_page\n            &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n            &gt;&gt;&gt; pdf = pdfplumber.open(x)\n            &gt;&gt;&gt; page = pdf.pages[1] # page 2\n            &gt;&gt;&gt; im = get_img_from_page(page)\n            &gt;&gt;&gt; crop = PageCut.set(page, y0=0, y1=page.height * 0.1)\n            &gt;&gt;&gt; crop.extract_text()\n            'Resolution 2 A.M. No. P-14-3182'\n            &gt;&gt;&gt; pdf.close()\n        Args:\n            page (Page): pdfplumber Page object\n            y0 (float | int): Top y-axis\n            y1 (float | int): Bottom y-axis\n        Returns:\n            CroppedPage: The page crop where to extract text from.\n        \"\"\"\nSIDE_MARGIN = 50\nx0, x1 = SIDE_MARGIN, page.width - SIDE_MARGIN\nreturn cls(page=page, x0=x0, x1=x1, y0=y0, y1=y1).slice\n</code></pre>"},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut-attributes","title":"Attributes","text":""},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut.slice","title":"<code>slice: CroppedPage</code>  <code>property</code>","text":"<p>Unlike slicing from an image based on a <code>numpy.ndarray</code>, a page cut implies a page derived from <code>pdfplumber</code>. The former is based on pixels; the latter on points.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_page_and_img\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; page, im = get_page_and_img(x, 0) # page 1\n&gt;&gt;&gt; page.height\n948.72\n&gt;&gt;&gt; cutpage = PageCut(page=page, x0=100, x1=200, y0=100, y1=200).slice\n&gt;&gt;&gt; cutpage.height\n100\n&gt;&gt;&gt; page.pdf.close()\n</code></pre> <p>Returns:</p> Name Type Description <code>CroppedPage</code> <code>CroppedPage</code> <p>The page crop where to extract text from.</p>"},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut-functions","title":"Functions","text":""},{"location":"utils/#corpus_unpdf.src.common.slice.PageCut.set","title":"<code>set(page, y0, y1)</code>  <code>classmethod</code>","text":"<p>Using a uniform margin on the x-axis, supply the page to generate page width and thus force preset margins. The <code>y0</code> and <code>y1</code> fields determine how to slice the page.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_img_from_page\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; pdf = pdfplumber.open(x)\n&gt;&gt;&gt; page = pdf.pages[1] # page 2\n&gt;&gt;&gt; im = get_img_from_page(page)\n&gt;&gt;&gt; crop = PageCut.set(page, y0=0, y1=page.height * 0.1)\n&gt;&gt;&gt; crop.extract_text()\n'Resolution 2 A.M. No. P-14-3182'\n&gt;&gt;&gt; pdf.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>pdfplumber Page object</p> required <code>y0</code> <code>float | int</code> <p>Top y-axis</p> required <code>y1</code> <code>float | int</code> <p>Bottom y-axis</p> required <p>Returns:</p> Name Type Description <code>CroppedPage</code> <code>CroppedPage</code> <p>The page crop where to extract text from.</p> Source code in <code>corpus_unpdf/src/common/slice.py</code> Python<pre><code>@classmethod\ndef set(cls, page: Page, y0: float | int, y1: float | int) -&gt; CroppedPage:\n\"\"\"Using a uniform margin on the x-axis, supply the page\n    to generate page width and thus force preset margins. The `y0`\n    and `y1` fields determine how to slice the page.\n    Examples:\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from corpus_unpdf.src.common.fetch import get_img_from_page\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; pdf = pdfplumber.open(x)\n        &gt;&gt;&gt; page = pdf.pages[1] # page 2\n        &gt;&gt;&gt; im = get_img_from_page(page)\n        &gt;&gt;&gt; crop = PageCut.set(page, y0=0, y1=page.height * 0.1)\n        &gt;&gt;&gt; crop.extract_text()\n        'Resolution 2 A.M. No. P-14-3182'\n        &gt;&gt;&gt; pdf.close()\n    Args:\n        page (Page): pdfplumber Page object\n        y0 (float | int): Top y-axis\n        y1 (float | int): Bottom y-axis\n    Returns:\n        CroppedPage: The page crop where to extract text from.\n    \"\"\"\nSIDE_MARGIN = 50\nx0, x1 = SIDE_MARGIN, page.width - SIDE_MARGIN\nreturn cls(page=page, x0=x0, x1=x1, y0=y0, y1=y1).slice\n</code></pre>"}]}