{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"corpus-unpdf Docs","text":"<p>PDF, as a file format, is the bane of programmatic text analysis.</p> <p>It's not a document format like <code>.txt</code>, <code>.docx</code>, <code>.md</code>, etc. where elements of a document such as (a) layout, (b) words, (c) lines, etc. can be extracted easily.</p> <p>Instead, PDFs can be equated to instructions producing human-comprehensible, yet machine-confusing outputs.</p> <p>Humans can eyeball these outputs and understand the result. Machines however can only parse and make a guess as to its contents. Put another way:</p> <p>Note</p> <p>PDF = humans good, machines bad</p> <p>In light of this context, this library is an attempt to parse Philippine Supreme Court decisions issued in PDF format and extract its raw \"as guessed\" output.</p>"},{"location":"#modes","title":"Modes","text":"<ol> <li>Simple extraction via pdfplumber</li> <li>OCR-based extraction via opencv + tesseract</li> </ol>"},{"location":"#setup","title":"Setup","text":""},{"location":"#common-libraries","title":"Common libraries","text":"<p>Install common libraries in MacOS with <code>homebrew</code>:</p> Bash<pre><code>brew install tesseract\nbrew install imagemagick\nbrew info imagemagick # check version\n</code></pre> <p>The last command gets you the local folder installed which will be needed in creating the virtual environment:</p> Text Only<pre><code>==&gt; imagemagick: stable 7.1.0-59 (bottled), HEAD\nTools and libraries to manipulate images in many formats\nhttps://imagemagick.org/index.php\n/opt/homebrew/Cellar/imagemagick/7.1.0-59 (807 files, 31MB) * &lt;---- first part is the local folder\nx x x\n</code></pre> <p>Note that both <code>tesseract</code> and <code>imagemagick</code> libraries are also made preconditions in <code>.github/workflows/main.yaml</code>:</p> YAML<pre><code>steps:\n# see https://github.com/madmaze/pytesseract/blob/master/.github/workflows/ci.yaml\n- name: Install tesseract\nrun: sudo apt-get -y update &amp;&amp; sudo apt-get install -y tesseract-ocr tesseract-ocr-fra\n- name: Print tesseract version\nrun: echo $(tesseract --version)\n# see https://github.com/jsvine/pdfplumber/blob/stable/.github/workflows/tests.yml\n- name: Install ghostscript &amp; imagemagick\nrun: sudo apt update &amp;&amp; sudo apt install ghostscript libmagickwand-dev\n- name: Remove policy.xml\nrun: sudo rm /etc/ImageMagick-6/policy.xml # this needs to be removed or the test won't run\n</code></pre>"},{"location":"#virtual-environment","title":"Virtual environment","text":"<p>Update <code>.env</code> whenever <code>imagemagick</code> changes</p> <p>The shared dependency is based on <code>MAGICK_HOME</code> folder. This can't seem to be fetched by python (at least in 3.11) so we need to help it along by explicitly declaring its location. The folder can change when a new version is installed via <code>brew upgrade imagemagick</code></p> <p>Create an .env file and use the folder as the environment variable <code>MAGICK_HOME</code>:</p> Text Only<pre><code>MAGICK_HOME=/opt/homebrew/Cellar/imagemagick/7.1.0-59\n</code></pre> <p>This configuration will allow <code>pdfplumber</code> to detect <code>imagemagick</code>.</p> <p>Effect of not setting <code>MAGICK_HOME</code>:</p> Python<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; pdfplumber.open&lt;(testpath&gt;).pages[0].to_image(resolution=300) # ERROR\n</code></pre> Text Only<pre><code>OSError: cannot find library; tried paths: []\n\nDuring handling of the above exception, another exception occurred:\n\nImportError                               Traceback (most recent call last)\n...\nImportError: MagickWand shared library not found.\nYou probably had not installed ImageMagick library.\nTry to install:\n  brew install freetype imagemagick\n</code></pre> <p>With <code>MAGICK_HOME</code>:</p> Python<pre><code>&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; pdfplumber.open&lt;(testpath&gt;).pages[0].to_image\nPIL.Image.Image # image library and type detected\n</code></pre> <p>Proceed to create the environment using <code>poetry update</code> which will install the following into a separate virtual environment:</p> TOML<pre><code>[tool.poetry.dependencies]\npython = \"^3.11\"\npython-dotenv = \"^0.21\"\npdfplumber = \"^0.7.6\" # from pdf to txt\npillow = \"^9.4.0\" # from pdf to img\nopencv-python = \"^4.7.0.68\" # img manipulation\npytesseract = \"^0.3.10\" # map manipulated img\n</code></pre>"},{"location":"blocks/","title":"PDF to Blocks","text":""},{"location":"blocks/#all-pages-of-a-pdf-as-blocks","title":"All pages of a PDF as blocks","text":"<p>Following an experimental layout from <code>pdfplumber</code>, generate contextualized blocks based on some regex patterns.</p> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>Path</code> <p>description</p> required <p>Yields:</p> Type Description <code>Iterator[dict[str, Any]]</code> <p>Iterator[dict[str, Any]]: description</p> Source code in <code>corpus_unpdf/blocks/pdf_blocks.py</code> Python<pre><code>def extract_blocks(pdfpath: Path) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Following an experimental layout from `pdfplumber`,\n    generate contextualized blocks based on some regex patterns.\n    Args:\n        pdfpath (Path): _description_\n    Yields:\n        Iterator[dict[str, Any]]: _description_\n    \"\"\"\npdf = pdfplumber.open(pdfpath)\nfor counter, page in enumerate(pdf.pages):\nif counter != 0:  # assumes only first page does not need to be cropped\npage = page.crop(\nbbox=(0, 0.09 * float(page.height), page.width, page.height),\nrelative=False,\nstrict=True,\n)\npage_structure = page.extract_text(\nlayout=True,  # experimental, follows page structure spacing\nkeep_blank_chars=True,  # enables more context in spacing\n)\ncontent_of_page = standardize(page_structure)\nnewlines_preceded_by_spaces = space_break_letter.split(content_of_page)\nfor counter, line in enumerate(newlines_preceded_by_spaces):\nremove_false_breaks = break_between_small_letters.sub(\" \", line)\nlines_proper = remove_false_breaks.splitlines()\nfor subcounter, text in enumerate(lines_proper):\nyield {\n\"page\": page.page_number,\n\"counter\": counter,\n\"line\": subcounter,\n\"text\": text,\n}\n</code></pre>"},{"location":"images/image/","title":"PDF to Image","text":""},{"location":"images/image/#all-pages-of-a-pdf-as-images","title":"All pages of a PDF as images","text":"<p>Extract from <code>pdfpath</code> the <code>PIL</code>-based images of all the pages of the file.</p> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>Path</code> <p>Source of the PDF to examine</p> required <p>Yields:</p> Type Description <code>Iterator[Image.Image]</code> <p>Iterator[Image.Image]: Image of each page found in the file.</p> Source code in <code>corpus_unpdf/images/pdf_img.py</code> Python<pre><code>def get_imgs(pdfpath: Path) -&gt; Iterator[Image.Image]:\n\"\"\"Extract from `pdfpath` the `PIL`-based images of all the pages\n    of the file.\n    Args:\n        pdfpath (Path): Source of the PDF to examine\n    Yields:\n        Iterator[Image.Image]: Image of each page found in the file.\n    \"\"\"\npdf = pdfplumber.open(pdfpath)\nprint(f\"Pages detected: {len(pdf.pages)}\")\nfor page in pdf.pages:\nimg = page.to_image(resolution=300)\nif isinstance(img.original, Image.Image):\nyield img.original\n</code></pre>"},{"location":"images/image/#single-page-of-a-pdf-as-image","title":"Single page of a PDF as image","text":"<p>Extract from <code>pdfpath</code> the <code>PIL</code>-based image represented by the <code>pagenum</code> of the file.</p> <p>Parameters:</p> Name Type Description Default <code>pdfpath</code> <code>str | Path</code> <p>Source of the PDF to examine</p> required <code>pagenum</code> <code>int</code> <p>The page number of the PDF</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>PIL not generated.</p> <p>Returns:</p> Type Description <code>Image.Image</code> <p>Image.Image: Image represented by the pagenum of the file.</p> Source code in <code>corpus_unpdf/images/pdf_img.py</code> Python<pre><code>def get_img(pdfpath: str | Path, pagenum: int) -&gt; Image.Image:\n\"\"\"Extract from `pdfpath` the `PIL`-based image represented\n    by the `pagenum` of the file.\n    Args:\n        pdfpath (str | Path): Source of the PDF to examine\n        pagenum (int): The page number of the PDF\n    Raises:\n        Exception: PIL not generated.\n    Returns:\n        Image.Image: Image represented by the pagenum of the file.\n    \"\"\"\npdf = pdfplumber.open(pdfpath)\npage = pdf.pages[pagenum]\nimg = page.to_image(resolution=300)\nif isinstance(img.original, Image.Image):\nreturn img.original\nraise Exception(\"Could not get PIL-formatted image.\")\n</code></pre>"},{"location":"images/lines/","title":"PDF to Contextualized Lines","text":""},{"location":"images/lines/#lines-from-layout","title":"Lines From Layout","text":"<p>         Bases: <code>Enum</code></p> <p>Layouting sections mapped to a Supreme Court decision:</p> <ol> <li>Header</li> <li>Body</li> <li>Footer</li> </ol> Source code in <code>corpus_unpdf/images/pdf_layout.py</code> Python<pre><code>class PageLayout(Enum):\n\"\"\"Layouting sections mapped to a Supreme Court decision:\n    1. Header\n    2. Body\n    3. Footer\n    \"\"\"\nHeader = \"header\"\nBody = \"body\"\nAnnex = \"annex\"\ndef get_texts(self, page_num: int, text: str) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Given a section of the page, split up the page\n        first by double-spaced newlines and then remove\n        each newline contained within this initial split.\n        Args:\n            page_num (int): Page number represented by the text\n            text (str): The converted text from its original image\n        Yields:\n            Iterator[dict[str, Any]]: Contextualized layouted line\n        \"\"\"\nparagraphs = double_space.split(standardize(text))\nfor pos, paragraph_text in enumerate(paragraphs):\ntext = newline.sub(\" \", paragraph_text)\nbase = {\"layout\": self, \"page\": page_num, \"pos\": pos, \"text\": text}\nif self == PageLayout.Header:\nyield base | extract_header_meta(paragraph_text)\nelse:\nyield base\n</code></pre>"},{"location":"images/lines/#corpus_unpdf.images.pdf_layout.PageLayout-functions","title":"Functions","text":""},{"location":"images/lines/#corpus_unpdf.images.pdf_layout.PageLayout.get_texts","title":"<code>get_texts(page_num, text)</code>","text":"<p>Given a section of the page, split up the page first by double-spaced newlines and then remove each newline contained within this initial split.</p> <p>Parameters:</p> Name Type Description Default <code>page_num</code> <code>int</code> <p>Page number represented by the text</p> required <code>text</code> <code>str</code> <p>The converted text from its original image</p> required <p>Yields:</p> Type Description <code>Iterator[dict[str, Any]]</code> <p>Iterator[dict[str, Any]]: Contextualized layouted line</p> Source code in <code>corpus_unpdf/images/pdf_layout.py</code> Python<pre><code>def get_texts(self, page_num: int, text: str) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Given a section of the page, split up the page\n    first by double-spaced newlines and then remove\n    each newline contained within this initial split.\n    Args:\n        page_num (int): Page number represented by the text\n        text (str): The converted text from its original image\n    Yields:\n        Iterator[dict[str, Any]]: Contextualized layouted line\n    \"\"\"\nparagraphs = double_space.split(standardize(text))\nfor pos, paragraph_text in enumerate(paragraphs):\ntext = newline.sub(\" \", paragraph_text)\nbase = {\"layout\": self, \"page\": page_num, \"pos\": pos, \"text\": text}\nif self == PageLayout.Header:\nyield base | extract_header_meta(paragraph_text)\nelse:\nyield base\n</code></pre>"},{"location":"images/lines/#lines-from-page","title":"Lines From Page","text":"<p>Given a page, extract layout of it (if possible), then for each layout, get contextualized lines.</p> <p>Parameters:</p> Name Type Description Default <code>page_num</code> <code>int</code> <p>description</p> required <code>img</code> <code>Image.Image</code> <p>description</p> required <p>Yields:</p> Type Description <code>Iterator[dict[str, Any]]</code> <p>Iterator[dict[str, Any]]: Lines of the pdf represented in dict format.</p> Source code in <code>corpus_unpdf/images/pdf_lines.py</code> Python<pre><code>def extract_page_lines(\npage_num: int, img: Image.Image\n) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Given a page, extract layout of it (if possible), then\n    for each layout, get contextualized lines.\n    Args:\n        page_num (int): _description_\n        img (Image.Image): _description_\n    Yields:\n        Iterator[dict[str, Any]]: Lines of the pdf represented in dict format.\n    \"\"\"\nprint(f\"Extracting {page_num=}\")\nopencvImage = cv2.cvtColor(numpy.array(img), cv2.COLOR_RGB2BGR)\nim_h, im_w, im_d = opencvImage.shape\nbase = opencvImage.copy()\nif slices := extract_slices(base, opencvImage):\nyield from PageLayout.Header.get_texts(\npage_num=page_num,\ntext=pytesseract.image_to_string(slices[0]),\n)\nyield from PageLayout.Body.get_texts(\npage_num=page_num,\ntext=pytesseract.image_to_string(slices[1]),\n)\nyield from PageLayout.Annex.get_texts(\npage_num=page_num,\ntext=pytesseract.image_to_string(slices[2]),\n)\nelse:\nsans_header = base[HEADER_TOP:im_h, 0:im_w]\nyield from PageLayout.Body.get_texts(\npage_num=page_num,\ntext=pytesseract.image_to_string(sans_header),\n)\n</code></pre>"},{"location":"images/lines/#lines-from-path","title":"Lines From Path","text":"<p>Given a <code>pdf_file_path</code>, get contextualized lines that specify</p> <p>Parameters:</p> Name Type Description Default <code>pdf_file_path</code> <code>Path</code> <p>Path to the image.</p> required <p>Yields:</p> Type Description <code>Iterator[dict[str, Any]]</code> <p>Iterator[dict[str, Any]]: Each line's layout category, page number, and actual text deciphered from the pdf.</p> Source code in <code>corpus_unpdf/images/pdf_lines.py</code> Python<pre><code>def extract_lines_from_pdf(pdf_file_path: Path) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Given a `pdf_file_path`, get contextualized lines that\n    specify\n    Args:\n        pdf_file_path (Path): Path to the image.\n    Yields:\n        Iterator[dict[str, Any]]: Each line's layout category, page number,\n            and actual text deciphered from the pdf.\n    \"\"\"\npil_formatted_imgs = get_imgs(pdf_file_path)\nfor num, img in enumerate(pil_formatted_imgs, start=1):\nyield from extract_page_lines(num, img)\n</code></pre>"},{"location":"images/text/","title":"Lines to Text","text":"<p>Using contextualized lines, create a text file based on PageLayout sections.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>Iterator[dict]</code> <p>description</p> required <code>p</code> <code>Path</code> <p>description. Defaults to temp_file.</p> <code>temp_file</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>description</p> Source code in <code>corpus_unpdf/images/pdf_txt.py</code> Python<pre><code>def set_file(lines: Iterator[dict], p: Path = temp_file) -&gt; Path:\n\"\"\"Using contextualized lines, create a text file based on\n    PageLayout sections.\n    Args:\n        lines (Iterator[dict]): _description_\n        p (Path, optional): _description_. Defaults to temp_file.\n    Returns:\n        Path: _description_\n    \"\"\"\ndecision_type = None\ndate_found = None\nannex_texts = []\ndecision_texts = []\nfor line in lines:\nif layout := line.get(\"layout\"):\nif layout == PageLayout.Header:\nif decision_type is None and line.get(\"decision_type\"):\ndecision_type = line[\"decision_type\"]\nif date_found is None and line.get(\"date_found\"):\ndate_found = line[\"date_found\"]\nif layout == PageLayout.Body:\ndecision_texts.append(line.get(\"text\"))\nif layout == PageLayout.Annex:\nannex_texts.append(line.get(\"text\"))\nwith open(p, \"w+\") as target:\ntarget.write(f\"Type: {decision_type}\\n\")\nif date_found:\ntarget.write(f\"Date: {date_found}\\n\")\ntarget.write(SEPARATOR)\ntarget.write(\"\\n\\n\".join(decision_texts))\ntarget.write(SEPARATOR)\ntarget.write(\"\\n\\n\".join(annex_texts))\nreturn p\n</code></pre>"}]}