{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"corpus-unpdf Docs","text":"<p>Utilizes <code>start-ocr</code> \"primitive\" functions.</p>"},{"location":"#applicability","title":"Applicability","text":"<p>Documents in PH Supreme Court 2023 website:</p> <ol> <li>Decision / Resolution</li> <li>Separate Opinions in the latter</li> </ol> <p>Each document will have:</p> Page type Note start there will be a deliberate start \"y-axis\" position affected by markers content see <code>start-ocr</code> end there will be a deliberate end \"y-axis\" position <p>The y-axis is relevant to slice the header and the footer to arrive at the meat of each page.</p>"},{"location":"#get_decision","title":"get_decision","text":"<p>From a *.pdf file found in <code>path</code>, extract relevant metadata to generate a decision having content pages. Each of which will contain a body and, likely, an annex for footnotes.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n&gt;&gt;&gt; decision = get_decision(x)\n&gt;&gt;&gt; decision.category\n&lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n&gt;&gt;&gt; decision.composition\n&lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n&gt;&gt;&gt; decision.writer\n'CARPIO. J.:'\n&gt;&gt;&gt; len(decision.pages) # total page count\n5\n&gt;&gt;&gt; isinstance(decision.pages[0], Content) # first page\nTrue\n&gt;&gt;&gt; isinstance(decision.segments[0], Bodyline)\nTrue\n&gt;&gt;&gt; isinstance(decision.footnotes[0], Footnote)\nTrue\n&gt;&gt;&gt; len(decision.footnotes) # TODO: limited number detected; should be 15\n7\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Decision</code> <p>Instance of a Decision with pages populated</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def get_decision(path: Path) -&gt; Decision:\n\"\"\"From a _*.pdf_ file found in `path`, extract relevant metadata\n    to generate a decision having content pages. Each of which will contain a body and,\n    likely, an annex for footnotes.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"decision.pdf\"\n        &gt;&gt;&gt; decision = get_decision(x)\n        &gt;&gt;&gt; decision.category\n        &lt;DecisionCategoryChoices.RESO: 'Resolution'&gt;\n        &gt;&gt;&gt; decision.composition\n        &lt;CourtCompositionChoices.DIV2: 'Second Division'&gt;\n        &gt;&gt;&gt; decision.writer\n        'CARPIO. J.:'\n        &gt;&gt;&gt; len(decision.pages) # total page count\n        5\n        &gt;&gt;&gt; isinstance(decision.pages[0], Content) # first page\n        True\n        &gt;&gt;&gt; isinstance(decision.segments[0], Bodyline)\n        True\n        &gt;&gt;&gt; isinstance(decision.footnotes[0], Footnote)\n        True\n        &gt;&gt;&gt; len(decision.footnotes) # TODO: limited number detected; should be 15\n        7\n    Args:\n        path (Path): Path to the pdf file.\n    Returns:\n        Self: Instance of a Decision with pages populated\n    \"\"\"  # noqa: E501\nmeta = DecisionMeta.prep(path)\nwith pdfplumber.open(path) as pdf:\n# create all the pages of the decision\ncaso = meta.init(pdf=pdf)\ncontent_pages = meta.add(pages=pdf.pages)\ncaso.pages.extend(content_pages)\n# construct full decision\nobj = construct(caso)\nif isinstance(obj, Decision):\nreturn obj\nraise Exception(\"Bad construction of Decision.\")\n</code></pre>"},{"location":"#decisionmeta","title":"DecisionMeta","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Metadata required to create a decision.</p> Field Type Description <code>start_index</code> int The zero-based integer <code>x</code>, i.e. get specific <code>pdfplumber.pages[x]</code> <code>start_page_num</code> int The 1-based integer to describe human-readable page number <code>start_indicator</code> PositionDecisionCategoryWriter or PositionNotice Marking the start of the content proper <code>writer</code> str When PositionDecisionCategoryWriter  is selected, the writer found underneath the category <code>notice</code> bool Will be marked <code>True</code>, if PositionNotice is selected; default is <code>False</code>. <code>pages</code> list[Content] A list of pages having material content Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>class DecisionMeta(NamedTuple):\n\"\"\"Metadata required to create a [decision][decision-document].\n    Field | Type | Description\n    --:|:--:|:--\n    `start_index` | int | The zero-based integer `x`, i.e. get specific `pdfplumber.pages[x]`\n    `start_page_num` | int | The 1-based integer to describe human-readable page number\n    `start_indicator` | [PositionDecisionCategoryWriter][decision-category-writer] or [PositionNotice][notice] | Marking the start of the content proper\n    `writer` | str | When [PositionDecisionCategoryWriter][decision-category-writer]  is selected, the writer found underneath the category\n    `notice` | bool | Will be marked `True`, if [PositionNotice][notice] is selected; default is `False`.\n    `pages` | list[Content] | A list of pages having material content\n    \"\"\"  # noqa: E501\nstart_index: int\nstart_page_num: int\nstart_indicator: PositionDecisionCategoryWriter | PositionNotice\nend_page_num: int\nend_page_pos: float | int\n@classmethod\ndef prep(cls, path: Path):\nif not (starter := get_start_page_pos(path)):\nraise Exception(\"Could not detect start of content.\")\nindex, start_indicator = starter\nif not start_indicator:\nraise Exception(\"Could not detect start indicator.\")\nender = get_end_page_pos(path)\nif not ender:\nraise Exception(\"Could not detect end of content.\")\nend_page_num, end_page_pos = ender\nreturn cls(\nstart_index=index,\nstart_page_num=index + 1,\nstart_indicator=start_indicator,\nend_page_num=end_page_num,\nend_page_pos=end_page_pos,\n)\ndef init(self, pdf: PDF) -&gt; Decision:\n\"\"\"Add the metadata of a [Decision][decision-document] and extract the first\n        page of the content proper which may not necessarily be page 1.\n        Returns:\n            Decision: A Decision instance, if all elements match.\n        \"\"\"\nlogger.debug(f\"Initialize {self=}\")\ncomposition = PositionCourtComposition.from_pdf(pdf).element\nstart_page = pdf.pages[self.start_index]\nif isinstance(self.start_indicator, PositionNotice):\nreturn Decision(\ncomposition=composition,\nnotice=True,\npages=[\nContent.set(\npage=start_page,\nstart_y=self.start_indicator.position_pct_height\n* start_page.height,\n)\n],\n)\nelif isinstance(self.start_indicator, PositionDecisionCategoryWriter):\nreturn Decision(\ncomposition=composition,\ncategory=self.start_indicator.element,\nwriter=self.start_indicator.writer,\npages=[\nContent.set(\npage=start_page,\nstart_y=self.start_indicator.writer_pct_height\n* start_page.height,\n)\n],\n)\nraise Exception(\"Unexpected initialization of decision.\")\ndef add(self, pages: list[Page]) -&gt; Iterator[Content]:\nfor nxt in pages:\nif nxt.page_number &lt;= self.start_page_num:\ncontinue\nif nxt.page_number == self.end_page_num:\nlogger.debug(f\"Finalize {nxt.page_number=}.\")\nif page_valid := Content.set(page=nxt, end_y=self.end_page_pos):\nyield page_valid\nelse:\nlogger.warning(\"Detected blank page.\")\nbreak\nelse:\nlogger.debug(f\"Initialize {nxt.page_number=}.\")\nif page_valid := Content.set(page=nxt):\nyield page_valid\nelse:\nlogger.warning(\"Detected blank page.\")\n</code></pre>"},{"location":"#corpus_unpdf.decision.DecisionMeta-functions","title":"Functions","text":""},{"location":"#corpus_unpdf.decision.DecisionMeta.init","title":"<code>init(pdf)</code>","text":"<p>Add the metadata of a Decision and extract the first page of the content proper which may not necessarily be page 1.</p> <p>Returns:</p> Name Type Description <code>Decision</code> <code>Decision</code> <p>A Decision instance, if all elements match.</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def init(self, pdf: PDF) -&gt; Decision:\n\"\"\"Add the metadata of a [Decision][decision-document] and extract the first\n    page of the content proper which may not necessarily be page 1.\n    Returns:\n        Decision: A Decision instance, if all elements match.\n    \"\"\"\nlogger.debug(f\"Initialize {self=}\")\ncomposition = PositionCourtComposition.from_pdf(pdf).element\nstart_page = pdf.pages[self.start_index]\nif isinstance(self.start_indicator, PositionNotice):\nreturn Decision(\ncomposition=composition,\nnotice=True,\npages=[\nContent.set(\npage=start_page,\nstart_y=self.start_indicator.position_pct_height\n* start_page.height,\n)\n],\n)\nelif isinstance(self.start_indicator, PositionDecisionCategoryWriter):\nreturn Decision(\ncomposition=composition,\ncategory=self.start_indicator.element,\nwriter=self.start_indicator.writer,\npages=[\nContent.set(\npage=start_page,\nstart_y=self.start_indicator.writer_pct_height\n* start_page.height,\n)\n],\n)\nraise Exception(\"Unexpected initialization of decision.\")\n</code></pre>"},{"location":"#get_opinion","title":"get_opinion","text":"<p>From a *.pdf file found in <code>path</code>, extract relevant opinion metadata to generate an opinion having content pages. Each of which will contain a body and, likely, an annex for footnotes.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"opinion.pdf\"\n&gt;&gt;&gt; opinion = get_opinion(x)\n&gt;&gt;&gt; opinion.writer\n'HERNANDO, J.:'\n&gt;&gt;&gt; opinion.label\n'DISSENTING OPINION'\n&gt;&gt;&gt; len(opinion.pages) # total page count\n28\n&gt;&gt;&gt; isinstance(opinion.pages[0], Content) # first page\nTrue\n&gt;&gt;&gt; isinstance(opinion.segments[0], Bodyline)\nTrue\n&gt;&gt;&gt; isinstance(opinion.footnotes[0], Footnote)\nTrue\n&gt;&gt;&gt; len(opinion.footnotes)\n50\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the pdf file.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Opinion</code> <p>Instance of an Opinion with pages populated</p> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>def get_opinion(path: Path) -&gt; Opinion:\n\"\"\"From a _*.pdf_ file found in `path`, extract relevant opinion metadata\n    to generate an opinion having content pages. Each of which will contain a body and, likely, an annex for footnotes.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"opinion.pdf\"\n        &gt;&gt;&gt; opinion = get_opinion(x)\n        &gt;&gt;&gt; opinion.writer\n        'HERNANDO, J.:'\n        &gt;&gt;&gt; opinion.label\n        'DISSENTING OPINION'\n        &gt;&gt;&gt; len(opinion.pages) # total page count\n        28\n        &gt;&gt;&gt; isinstance(opinion.pages[0], Content) # first page\n        True\n        &gt;&gt;&gt; isinstance(opinion.segments[0], Bodyline)\n        True\n        &gt;&gt;&gt; isinstance(opinion.footnotes[0], Footnote)\n        True\n        &gt;&gt;&gt; len(opinion.footnotes)\n        50\n    Args:\n        path (Path): Path to the pdf file.\n    Returns:\n        Self: Instance of an Opinion with pages populated\n    \"\"\"  # noqa: E501\nwith pdfplumber.open(path) as pdf:\nmeta = PositionOpinion.from_pdf(pdf)\n# initialize the opinion\nstart_page = pdf.pages[0]\nstart_y = meta.writer_pct_height * start_page.height\nopinion = Opinion(\nlabel=meta.label,\nwriter=meta.writer,\npages=[Content.set(page=start_page, start_y=start_y)],\n)\n# create all the pages of the opinion\nfor page in pdf.pages[1:]:\nif page_valid := Content.set(page=page):\nopinion.pages.append(page_valid)\n# construct full opinion\nobj = construct(opinion)\nif isinstance(obj, Opinion):\nreturn obj\nraise Exception(\"Bad construction of Opinion.\")\n</code></pre>"},{"location":"document/","title":"Document","text":""},{"location":"document/#decision-document","title":"Decision Document","text":"<p>Metadata of a pdf file parsed via <code>get_decision()</code></p> Field Description <code>composition</code> The composition of the Supreme Court that decided the case <code>category</code> When available, whether the case is a \"Decision\" or a \"Resolution\" <code>header</code> The top portion of the page, usually excluded from metadata <code>writer</code> When available, the writer of the case <code>notice</code> When True, means that there is no <code>category</code> available <code>pages</code> A list of <code>Content</code> pages, see <code>start-ocr</code> <code>body</code> The compiled string consisting of each page's <code>body_text</code> <code>annex</code> The compiled string consisting of each page's <code>annex_text</code>, if existing <code>segments</code> Each <code>Bodyline</code> of the body's text, see <code>start-ocr</code> <code>footnotes</code> Each <code>Footnote</code> of the body's annex, see <code>start-ocr</code> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@dataclass\nclass Decision:\n\"\"\"Metadata of a pdf file parsed via `get_decision()`\n    Field | Description\n    --:|:--\n    `composition` | The composition of the Supreme Court that decided the case\n    `category` | When available, whether the case is a \"Decision\" or a \"Resolution\"\n    `header` | The top portion of the page, usually excluded from metadata\n    `writer` | When available, the writer of the case\n    `notice` | When True, means that there is no `category` available\n    `pages` | A list of `Content` pages, see `start-ocr`\n    `body` | The compiled string consisting of each page's `body_text`\n    `annex` | The compiled string consisting of each page's `annex_text`, if existing\n    `segments` | Each `Bodyline` of the body's text, see `start-ocr`\n    `footnotes` | Each `Footnote` of the body's annex, see `start-ocr`\n    \"\"\"\ncomposition: CourtCompositionChoices\ncategory: DecisionCategoryChoices | None = None\nheader: CroppedPage | None = None\nwriter: str | None = None\nnotice: bool = False\npages: list[Content] = field(default_factory=list)\nsegments: list[Bodyline] = field(default_factory=list)\nfootnotes: list[Footnote] = field(default_factory=list)\nbody: str = \"\"\nannex: str = \"\"\ndef __repr__(self) -&gt; str:\nreturn f\"Decision {self.composition.value}, pages {len(self.pages)}\"\n</code></pre>"},{"location":"document/#opinion-document","title":"Opinion Document","text":"<p>Metadata of a pdf file parsed via <code>get_opinion()</code></p> Field Description <code>label</code> How the opinion is labelled <code>writer</code> When available, the writer of the case <code>pages</code> A list of <code>Content</code> pages, see <code>start-ocr</code> <code>body</code> The compiled string consisting of each page's <code>body_text</code> <code>annex</code> The compiled string consisting of each page's <code>annex_text</code>, if existing <code>segments</code> Each <code>Bodyline</code> of the body's text, see <code>start-ocr</code> <code>footnotes</code> Each <code>Footnote</code> of the body's annex, see <code>start-ocr</code> Source code in <code>corpus_unpdf/decision.py</code> Python<pre><code>@dataclass\nclass Opinion:\n\"\"\"Metadata of a pdf file parsed via `get_opinion()`\n    Field | Description\n    --:|:--\n    `label` | How the opinion is labelled\n    `writer` | When available, the writer of the case\n    `pages` | A list of `Content` pages, see `start-ocr`\n    `body` | The compiled string consisting of each page's `body_text`\n    `annex` | The compiled string consisting of each page's `annex_text`, if existing\n    `segments` | Each `Bodyline` of the body's text, see `start-ocr`\n    `footnotes` | Each `Footnote` of the body's annex, see `start-ocr`\n    \"\"\"\nlabel: str\nwriter: str\npages: list[Content] = field(default_factory=list)\nsegments: list[Bodyline] = field(default_factory=list)\nfootnotes: list[Footnote] = field(default_factory=list)\nbody: str = \"\"\nannex: str = \"\"\ndef __repr__(self) -&gt; str:\nreturn f\"{self.writer.title()} | {self.label.title()}: pages {len(self.pages)}\"\n</code></pre>"},{"location":"markers/","title":"Markers","text":"<p>Typically used in the title page of a Decision document to determine the positions of Y-coordinates and to extract the metadata associated with the page.</p> <p>Warning</p> <p>Not all markers are found in the preliminary page. Hence, the need to find   the anchoring start of content.</p>"},{"location":"markers/#court-composition","title":"Court Composition","text":""},{"location":"markers/#composition-choices","title":"Composition Choices","text":"<p>         Bases: <code>Enum</code></p> <p>How the Supreme Court sits. At present, this includes four options: en banc + 3 divisions. Might need to add cases for special divisions.</p> Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class CourtCompositionChoices(Enum):\n\"\"\"How the Supreme Court sits. At present, this includes four\n    options: en banc + 3 divisions. Might need to add cases for _special_ divisions.\n    \"\"\"\nENBANC = \"En Banc\"\nDIV1 = \"First Division\"\nDIV2 = \"Second Division\"\nDIV3 = \"Third Division\"\n</code></pre>"},{"location":"markers/#extract-composition","title":"Extract Composition","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Should be present as the top centered element in the first page of the pdf of the Decision.</p> Field Type Description <code>element</code> CourtCompositionChoices Presently four choices <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the composition is found <code>composition_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class PositionCourtComposition(NamedTuple):\n\"\"\"Should be present as the top centered element in the first page\n    of the pdf of the Decision.\n    Field | Type | Description\n    --:|:--:|:--\n    `element` | [CourtCompositionChoices][composition-choices] | Presently four choices\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the composition is found\n    `composition_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    \"\"\"  # noqa: E501\nelement: CourtCompositionChoices\ncoordinates: tuple[int, int, int, int]\ncomposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in CourtCompositionChoices:\nif xywh := get_likelihood_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\ncomposition_pct_height=(y + h) / im_h,\n)\nreturn None\n@classmethod\ndef from_pdf(cls, pdf: PDF) -&gt; Self:\npage_one_im = get_img_from_page(pdf.pages[0])\ncourt_composition = cls.extract(page_one_im)\nif not court_composition:\nraise Exception(\"Could not detect court compositon in page 1.\")\nreturn court_composition\n</code></pre>"},{"location":"markers/#decision-category-writer","title":"Decision Category &amp; Writer","text":""},{"location":"markers/#category-choices","title":"Category Choices","text":"<p>         Bases: <code>Enum</code></p> <p>The classification of a decision issued by the Supreme Court, i.e. a decision or a resolution.</p> Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class DecisionCategoryChoices(Enum):\n\"\"\"The classification of a decision issued by the Supreme Court, i.e.\n    a decision or a resolution.\"\"\"\nCASO = \"Decision\"\nRESO = \"Resolution\"\n</code></pre>"},{"location":"markers/#extract-category","title":"Extract Category","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Should be present as the top centered element in the first page of the pdf of the Decision.</p> Field Type Description <code>element</code> DecisionCategoryChoices Presently four choices <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the <code>composition</code> element is found <code>writer</code> str The string found indicating the name of the writer <code>category_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. <code>writer_pct_height</code> float The writer's coordinates are found below the category coordinates. This can then be used to signify the anchoring start of the document. Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class PositionDecisionCategoryWriter(NamedTuple):\n\"\"\"Should be present as the top centered element in the first page\n    of the pdf of the Decision.\n    Field | Type | Description\n    --:|:--:|:--\n    `element` | [DecisionCategoryChoices][category-choices] | Presently four choices\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the `composition` element is found\n    `writer` | str | The string found indicating the name of the writer\n    `category_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    `writer_pct_height` | float | The writer's coordinates are found below the category coordinates. This can then be used to signify the anchoring start of the document.\n    \"\"\"  # noqa: E501\nelement: DecisionCategoryChoices\ncoordinates: tuple[int, int, int, int]\nwriter: str\ncategory_pct_height: float\nwriter_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in DecisionCategoryChoices:\nif xywh := get_likelihood_centered_coordinates(im, member.value):\n_, y, _, h = xywh\ny0, y1 = y + h, y + 270\nwriter_box = im[y0:y1]\nwriter = pytesseract.image_to_string(writer_box).strip()\nreturn cls(\nelement=member,\ncoordinates=xywh,\nwriter=writer,\ncategory_pct_height=y / im_h,\nwriter_pct_height=y1 / im_h,\n)\nreturn None\n</code></pre>"},{"location":"markers/#notice","title":"Notice","text":"<p>         Bases: <code>NamedTuple</code></p> <p>When present, signifies that this was issued by authority of the Court.</p> Field Type Description <code>element</code> NoticeChoices Only a single choice (for now) <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the notice is found <code>position_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class PositionNotice(NamedTuple):\n\"\"\"When present, signifies that this was issued by authority of the Court.\n    Field | Type | Description\n    --:|:--:|:--\n    `element` | NoticeChoices | Only a single choice (for now)\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the notice is found\n    `position_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    \"\"\"  # noqa: E501\nelement: NoticeChoices\ncoordinates: tuple[int, int, int, int]\nposition_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, _, _ = im.shape\nfor member in NoticeChoices:\nif xywh := get_likelihood_centered_coordinates(im, member.value):\ny, h = xywh[1], xywh[3]\nreturn cls(\nelement=member,\ncoordinates=xywh,\nposition_pct_height=(y + h) / im_h,\n)\nreturn None\n</code></pre>"},{"location":"markers/#opinion","title":"Opinion","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Should be present as the top centered element in the first page of the pdf of the Opinion.</p> Field Type Description <code>label</code> str Should be a phase including the word 'Opinion' <code>writer</code> str The string found indicating the name of the writer <code>coordinates</code> tuple[int, int, int, int] The opencv rectangle found in the page where the <code>label</code> is found <code>opinion_pct_height</code> float The <code>y</code> + height <code>h</code> of the <code>coordinates</code> over the <code>im_h</code> image height; used so the pdfplumber can utilize its cropping mechanism. <code>writer_pct_height</code> float The writer's coordinates are found below the label <code>coordinates</code>. This can then be used to signify the anchoring start of the document. Source code in <code>corpus_unpdf/_markers.py</code> Python<pre><code>class PositionOpinion(NamedTuple):\n\"\"\"Should be present as the top centered element in the first page\n    of the pdf of the Opinion.\n    Field | Type | Description\n    --:|:--:|:--\n    `label` | str | Should be a phase including the word 'Opinion'\n    `writer` | str | The string found indicating the name of the writer\n    `coordinates` | tuple[int, int, int, int] | The opencv rectangle found in the page where the `label` is found\n    `opinion_pct_height` | float | The `y` + height `h` of the `coordinates` over the `im_h` image height; used so the pdfplumber can utilize its cropping mechanism.\n    `writer_pct_height` | float | The writer's coordinates are found below the label `coordinates`. This can then be used to signify the anchoring start of the document.\n    \"\"\"  # noqa: E501\nlabel: str\nwriter: str\ncoordinates: tuple[int, int, int, int]\nopinion_pct_height: float\nwriter_pct_height: float\n@classmethod\ndef extract(cls, im: numpy.ndarray) -&gt; Self | None:\nim_h, im_w, _ = im.shape\nfor cnt in get_contours(im, (50, 50)):\nx, y, w, h = cv2.boundingRect(cnt)\nx0_mid_left = (1 * im_w) / 4 &lt; x\nendpoint_on_right = x + w &gt; im_w / 2\nshort_width = w &gt; 200\nif all([x0_mid_left, endpoint_on_right, short_width]):\nsliced_im = im[y : y + h, x : x + w]\nlabel = pytesseract.image_to_string(sliced_im).strip().upper()\ny0, y1 = y + h, y + 270\nwriter_box = im[y0:y1]\nwriter = pytesseract.image_to_string(writer_box).strip()\nif \"OPINION\" in label:\nreturn cls(\nlabel=label,\ncoordinates=(x, y, w, h),\nwriter=writer,\nopinion_pct_height=(y + h) / im_h,\nwriter_pct_height=y1 / im_h,\n)\nreturn None\n@classmethod\ndef from_pdf(cls, pdf: PDF) -&gt; Self:\npage_one_im = get_img_from_page(pdf.pages[0])\nopinion_label = cls.extract(page_one_im)\nif not opinion_label:\nraise Exception(\"Could not detect opinion in page 1.\")\nreturn opinion_label\n</code></pre>"},{"location":"positions/","title":"Positions","text":""},{"location":"positions/#terminal-start-page-position","title":"Terminal Start: Page, Position","text":"<p>Although the collection of pages has a logical start page, this exceptionally does not correspond to the actual start of the content.</p> <p>The actual start of content depends on either the detection of a Notice or a Category</p> <p>This requires searching the page from start to finish, via <code>get_pages_and_imgs()</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n&gt;&gt;&gt; res = get_start_page_pos(x)\n&gt;&gt;&gt; type(res[0])\n&lt;class 'int'&gt;\n&gt;&gt;&gt; res[0]\n0\n&gt;&gt;&gt; type(res[1])\n&lt;class 'corpus_unpdf._markers.PositionNotice'&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the PDF file.</p> required <p>Returns:</p> Type Description <code>tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None</code> <p>tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None: The zero-based index of the page (i.e. 0 = page 1), the marker found that signifies start of the content</p> Source code in <code>corpus_unpdf/_positions.py</code> Python<pre><code>def get_start_page_pos(\npath: Path,\n) -&gt; tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None:\n\"\"\"Although the collection of pages has a logical start page, this\n    _exceptionally_ does not correspond to the actual start of the content.\n    The actual start of content depends on either the detection of a\n    Notice or a Category\n    This requires searching the page from start to finish, via\n    `get_pages_and_imgs()`\n    Examples:\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n        &gt;&gt;&gt; res = get_start_page_pos(x)\n        &gt;&gt;&gt; type(res[0])\n        &lt;class 'int'&gt;\n        &gt;&gt;&gt; res[0]\n        0\n        &gt;&gt;&gt; type(res[1])\n        &lt;class 'corpus_unpdf._markers.PositionNotice'&gt;\n    Args:\n        path (Path): Path to the PDF file.\n    Returns:\n        tuple[int, PositionNotice | PositionDecisionCategoryWriter | None] | None:\n            The zero-based index of the page (i.e. 0 = page 1), the marker found that\n            signifies start of the content\n    \"\"\"\nfor page, im in get_pages_and_imgs(path):\nindex = page.page_number - 1  # represents the 0-based index\n_, im_w, _ = im.shape\nMIDPOINT = im_w / 2\nfor cnt in get_contours(im, (30, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\none_liner = h &lt; 100\nx_start_mid = x &lt; MIDPOINT\nx_end_mid = (x + w) &gt; MIDPOINT\nshort_width = 200 &lt; w &lt; 800\nif all([one_liner, x_start_mid, x_end_mid, short_width]):\nsliced = im[y : y + h, x : x + w]\n# cv2.rectangle(im, (x, y), (x + w, y + h), (36, 255, 12), 3)\n# print(f\"{x=}, {y=}, {w=}, {h=}\")\nif is_match_text(sliced, \"notice\"):\nreturn index, PositionNotice.extract(im)\nelif is_match_text(sliced, \"decision\"):\nreturn index, PositionDecisionCategoryWriter.extract(im)\nelif is_match_text(sliced, \"resolution\"):\nreturn index, PositionDecisionCategoryWriter.extract(im)\n# cv2.imwrite(f\"temp/sample_boxes-{page.page_number}.png\", im)\nreturn None\n</code></pre>"},{"location":"positions/#terminal-end-page-number-position","title":"Terminal End: Page Number, Position","text":"<p>Although the collection of pages has a logical end page, this oftentimes does not correspond to the actual end of the content.</p> <p>The actual end of content depends on either two pieces of text: the <code>Ordered</code> clause or <code>By Authority of the Court</code></p> <p>This requires searching the page in reverse, via <code>get_reverse_pages_and_imgs()</code> since the above pieces of text indicate the end of the content.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pdfplumber.page import Page\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pdfplumber\n&gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n&gt;&gt;&gt; get_end_page_pos(x) # page 5, y-axis 80.88\n(5, 80.88)\n</code></pre> <p>Also see snippets for debugging:</p> Python<pre><code>debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\ncv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\ncv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the PDF file.</p> required <p>Returns:</p> Type Description <code>tuple[int, int] | None</code> <p>tuple[int, int] | None: The page number from pdfplumber.pages, the Y position of that page</p> Source code in <code>corpus_unpdf/_positions.py</code> Python<pre><code>def get_end_page_pos(path: Path) -&gt; tuple[int, int] | None:\n\"\"\"Although the collection of pages has a logical end page, this\n    oftentimes does not correspond to the actual end of the content.\n    The actual end of content depends on either two pieces of text:\n    the `Ordered` clause or `By Authority of the Court`\n    This requires searching the page in reverse, via\n    `get_reverse_pages_and_imgs()` since the above pieces of text\n    indicate the end of the content.\n    Examples:\n        &gt;&gt;&gt; from pdfplumber.page import Page\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import pdfplumber\n        &gt;&gt;&gt; x = Path().cwd() / \"tests\" / \"data\" / \"notice.pdf\"\n        &gt;&gt;&gt; get_end_page_pos(x) # page 5, y-axis 80.88\n        (5, 80.88)\n    Also see snippets for debugging:\n    ```py\n    debug with print(f\"{x=}, {y=}, {w=}, {h=}, {y_pos=} {candidate=}\")\n    cv2.rectangle(im, (x,y), (x+w, y+h), (36, 255, 12), 3) # for each mark\n    cv2.imwrite(\"temp/sample_boxes.png\", im); see cv2.rectangle # end of forloop\n    ```\n    Args:\n        path (Path): Path to the PDF file.\n    Returns:\n        tuple[int, int] | None: The page number from pdfplumber.pages, the Y position\n            of that page\n    \"\"\"\nORDERED, AUTHORITY = \"so ordered\", \"by authority of the court\"\nfor page, im in get_reverse_pages_and_imgs(path):\nim_h, im_w, _ = im.shape\nMIDPOINT = im_w / 2\nfor cnt in get_contours(im, (30, 30)):\nx, y, w, h = cv2.boundingRect(cnt)\nsliced_im = im[y : y + h, x : x + w]\noutput = page.page_number, (y / im_h) * page.height\nif h &lt; 100:\nif x &lt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=ORDERED,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nelif x &gt; MIDPOINT:\nif is_match_text(\nsliced_im=sliced_im,\ntext_to_match=AUTHORITY,\nlikelihood=0.4,\n):\npage.pdf.close()\nreturn output\nreturn None\n</code></pre>"}]}